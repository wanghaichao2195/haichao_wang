<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode 1231 - Divide Chocolate</title>
      <link href="/11/26/2019/1231/"/>
      <url>/11/26/2019/1231/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximizeSweetness</span><span class="params">(<span class="keyword">int</span>[] sweetness, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : sweetness) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">            min = Math.min(num, min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (K + <span class="number">1</span> == <span class="number">1</span>) <span class="keyword">return</span> sum;<span class="comment">//注意是切K刀，变成K+1块儿</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//binary search between l and r</span></span><br><span class="line">        <span class="keyword">int</span> l = min, r = sum;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (valid(mid, sweetness, K + <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">//lower mid     </span></span><br><span class="line">                <span class="comment">//2 situations: either we successfully divide the array into m parts and the sum of each part is less than mid, or we used up all numbers before we reach m. Both of them mean that we should lower mid because we need to find the minimum one.</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">long</span> target, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            total += num;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; target) &#123;</span><br><span class="line">                total = <span class="number">0</span>;<span class="comment">//here is what different from 410, we can get a total bigger than target</span></span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; K) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// while (left &lt; right) &#123;</span></span><br><span class="line"><span class="comment">//     int mid = (left + right + 1) / 2;</span></span><br><span class="line"><span class="comment">//     int cur = 0, cuts = 0;</span></span><br><span class="line"><span class="comment">//     for (int a : A) &#123;</span></span><br><span class="line"><span class="comment">//         if ((cur += a) &gt;= mid) &#123;</span></span><br><span class="line"><span class="comment">//             cur = 0;</span></span><br><span class="line"><span class="comment">//             if (++cuts &gt; K) break;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     if (cuts &gt; K)</span></span><br><span class="line"><span class="comment">//         left = mid;</span></span><br><span class="line"><span class="comment">//     else</span></span><br><span class="line"><span class="comment">//         right = mid - 1;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BinarySearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 410 - Split Array Largest Sum</title>
      <link href="/11/25/2019/410/"/>
      <url>/11/25/2019/410/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// https://leetcode.com/problems/split-array-largest-sum/discuss/89817/Clear-Explanation%3A-8ms-Binary-Search-Java</span></span><br><span class="line">    <span class="comment">// time complexity is actually: </span></span><br><span class="line">    <span class="comment">//O(n*log(SumOfArray-MaxElementInArray))</span></span><br><span class="line"><span class="comment">// space complexity should be O(1) since we don't need to create a new array.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>; <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            max = Math.max(num, max);</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> (<span class="keyword">int</span>)sum;</span><br><span class="line">        <span class="comment">//binary search between maxSingleNumber and allSum</span></span><br><span class="line">        <span class="keyword">long</span> l = max; <span class="keyword">long</span> r = sum;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">long</span> mid = (l + r)/ <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (valid(mid, nums, m)) &#123;</span><br><span class="line">                <span class="comment">//lower mid     </span></span><br><span class="line">                <span class="comment">//2 situations: either we successfully divide the array into m parts and the sum of each part is less than mid, or we used up all numbers before we reach m. Both of them mean that we should lower mid because we need to find the minimum one.</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">long</span> target, <span class="keyword">int</span>[] nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            total += num;</span><br><span class="line">            <span class="keyword">if</span> (total &gt; target) &#123;</span><br><span class="line">                total = num;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; m) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BinarySearch DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 498 - Diagonal Traverse</title>
      <link href="/11/25/2019/498/"/>
      <url>/11/25/2019/498/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个是看到最好的方法。首先r+c奇偶不同可以决定向上向下。然后根据优先级，把条件写出来就好了。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findDiagonalOrder(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, m = matrix.length, n = matrix[<span class="number">0</span>].length, arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[m * n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        arr[i] = matrix[r][c];</span><br><span class="line">        <span class="keyword">if</span> ((r + c) % <span class="number">2</span> == <span class="number">0</span>) &#123; <span class="comment">// moving up</span></span><br><span class="line">            <span class="keyword">if</span>      (c == n - <span class="number">1</span>) &#123; r++; &#125;<span class="comment">//the sequence matters! explanation at end</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)     &#123; c++; &#125;</span><br><span class="line">            <span class="keyword">else</span>            &#123; r--; c++; &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                <span class="comment">// moving down</span></span><br><span class="line">            <span class="keyword">if</span>      (r == m - <span class="number">1</span>) &#123; c++; &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>)     &#123; r++; &#125;</span><br><span class="line">            <span class="keyword">else</span>            &#123; r++; c--; &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line"><span class="comment">//     you will get IndexOutBound Error. The reason is following:</span></span><br><span class="line"><span class="comment">// there will be a situation when we satisfy both these two statements, in case i, it is at right top corner, in this case, we can only goes down -- thus it has to first goto "col == n-1" check. Otherwise if goes to "row == 0" check we will have indexOutOfBound error since we can't do col++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Similarly, there will be a situation when we satisfy both these two statements, in case ii, it is at left bottom corner, in this case, we can only goes right --it has to first goto "row == m-1" check, Otherwise if goes to "col == 0" check we will have indexOutOfBound error since we can't do row++;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//总结就是：当向上走，有三种情况：r == 0， c == n - 1 或者 both</span></span><br><span class="line"><span class="comment">//both的时候r++,所以顺序很重要 c==n-1 优先级高。</span></span><br><span class="line"><span class="comment">//向下走同理。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Matrix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 247 - Strobogrammatic Number II</title>
      <link href="/11/25/2019/247/"/>
      <url>/11/25/2019/247/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//The recursive depth is indeed O(N), but during each recursive call,</span></span><br><span class="line">    <span class="comment">//we iterate through the list, and the list size increases exponentially with a factor of 5. </span></span><br><span class="line">    <span class="comment">//Therefore, the time complexity should be 5 + 5^2 + 5^3 + ... + 5^(N/2) ~= 5^(N/2)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">findStrobogrammatic</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(n, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">""</span>));</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"0"</span>, <span class="string">"1"</span>, <span class="string">"8"</span>));</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = helper(n - <span class="number">2</span>, m);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            String s = list.get(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (n != m) res.add(<span class="string">"0"</span> + s + <span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">            res.add(<span class="string">"1"</span> + s + <span class="string">"1"</span>);</span><br><span class="line">            res.add(<span class="string">"6"</span> + s + <span class="string">"9"</span>);</span><br><span class="line">            res.add(<span class="string">"8"</span> + s + <span class="string">"8"</span>);</span><br><span class="line">            res.add(<span class="string">"9"</span> + s + <span class="string">"6"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Math Recursion </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 718 - Maximum Length of Repeated Subarray (Longest Common Subarray)</title>
      <link href="/11/25/2019/718/"/>
      <url>/11/25/2019/718/</url>
      
        <content type="html"><![CDATA[<p>//516 718 1216 1143 5 those questions are also pretty alike this one.</p><p>In this quetion, i means for s1, range[0, i - 1] and j means for s2, range[0, j - 1]<br><code>So dp[i][j] means for first i elements in s1 and for first j elements in s2, what the LCS?</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//can also called longest common substring</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(m * n) time  O(m * n) space</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="keyword">int</span>[] A, <span class="keyword">int</span>[] B)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="keyword">null</span> || B == <span class="keyword">null</span>) <span class="keyword">return</span> max;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[A.length + <span class="number">1</span>][B.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//dp[0][0], dp[0][j], dp[i][0] all = zero</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= A.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= B.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i - <span class="number">1</span>] == B[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    max = Math.max(max, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP Dynamic Programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 257 - Binary Tree Paths</title>
      <link href="/11/24/2019/257/"/>
      <url>/11/24/2019/257/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n), space O(n) (completely unbalanced tree)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(root, <span class="string">""</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode node, String cur, List&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        </span><br><span class="line">        cur += String.valueOf(node.val);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (node.left == <span class="keyword">null</span> &amp;&amp; node.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            res.add(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(node.left, cur + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">        dfs(node.right, cur + <span class="string">"-&gt;"</span>, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS Binary-Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 947 - Most Stones Removed with Same Row or Column</title>
      <link href="/11/24/2019/947/"/>
      <url>/11/24/2019/947/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFind</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] parent;</span><br><span class="line">        <span class="keyword">int</span>[] rank;</span><br><span class="line">        <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFind</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123; <span class="comment">// for problem 200</span></span><br><span class="line">            parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            rank = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            count = n;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">                parent[i] = i;</span><br><span class="line">                <span class="comment">// rank[i] = 0;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="comment">// path compression</span></span><br><span class="line">            <span class="comment">// only the rank of the root matters, used in union op.</span></span><br><span class="line">            <span class="keyword">if</span> (parent[x] != x)</span><br><span class="line">                parent[x] = find(parent[x]);</span><br><span class="line">            <span class="keyword">return</span> parent[x];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="comment">// union with rank</span></span><br><span class="line">            <span class="keyword">int</span> rootx = find(x);</span><br><span class="line">            <span class="keyword">int</span> rooty = find(y);</span><br><span class="line">            <span class="keyword">if</span> (rootx != rooty) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rank[rootx] &gt; rank[rooty]) &#123;</span><br><span class="line">                    parent[rooty] = rootx;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent[rootx] = rooty;</span><br><span class="line">                    <span class="keyword">if</span> (rootx == rooty)</span><br><span class="line">                        rank[rooty] += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removeStones</span><span class="params">(<span class="keyword">int</span>[][] stones)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if any two points are on the same column or row, they are connected as a</span></span><br><span class="line">        <span class="comment">// edge.</span></span><br><span class="line">        <span class="comment">// find connected component, and remove all but one.</span></span><br><span class="line">        <span class="comment">// count the number of disjoint components.</span></span><br><span class="line">        <span class="keyword">int</span> n = stones.length;</span><br><span class="line">        UnionFind uf = <span class="keyword">new</span> UnionFind(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isConnected(stones[i], stones[j]))</span><br><span class="line">                    uf.union(i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把图画出来就明白了。总的节点数 - cluster数量，就是res</span></span><br><span class="line">        <span class="comment">//[[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]] : 6 - 1</span></span><br><span class="line">        <span class="comment">//[[0,0],[0,2],[1,1],[2,0],[2,2]] : 5 - 2</span></span><br><span class="line">        <span class="keyword">return</span> n - uf.getCount();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isConnected</span><span class="params">(<span class="keyword">int</span>[] p1, <span class="keyword">int</span>[] p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1[<span class="number">0</span>] == p2[<span class="number">0</span>] || p1[<span class="number">1</span>] == p2[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Union-Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 690 - Employee Importance</title>
      <link href="/11/24/2019/690/"/>
      <url>/11/24/2019/690/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//One employee has at most </span></span><br><span class="line">    <span class="comment">//one direct leader and may have several subordinates.(what if there are multiple leaders?)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//both time and space O(n)    BFS</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(List&lt;Employee&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Employee&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Employee employee : employees) &#123;</span><br><span class="line">            map.put(employee.id, employee);</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Employee&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(map.get(id));</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Employee current = queue.poll();</span><br><span class="line">            total += current.importance;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> subordinate : current.subordinates) &#123;</span><br><span class="line">                queue.offer(map.get(subordinate));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//     both time and space O(n)       recursive</span></span><br><span class="line"><span class="comment">//     public int getImportance(List&lt;Employee&gt; employees, int id) &#123;</span></span><br><span class="line"><span class="comment">//         Map&lt;Integer, Employee&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         for (Employee employee : employees) &#123;</span></span><br><span class="line"><span class="comment">//             map.put(employee.id, employee);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return getImportanceHelper(map, id);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     private int getImportanceHelper(Map&lt;Integer, Employee&gt; map, int rootId) &#123;</span></span><br><span class="line"><span class="comment">//         Employee root = map.get(rootId);</span></span><br><span class="line"><span class="comment">//         int total = root.importance;</span></span><br><span class="line"><span class="comment">//         for (int subordinate : root.subordinates) &#123;</span></span><br><span class="line"><span class="comment">//             total += getImportanceHelper(map, subordinate);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return total;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 339 - Nested List Weight Sum</title>
      <link href="/11/24/2019/339/"/>
      <url>/11/24/2019/339/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Time complexity: O(n)</span></span><br><span class="line">    <span class="comment">//Space complexity: O(max level of nesting) (O(n))</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nestedList == <span class="keyword">null</span> || nestedList.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nestedList, <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         if(nestedList == null)&#123;</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         int sum = 0;</span></span><br><span class="line"><span class="comment">//         int level = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         Queue&lt;NestedInteger&gt; queue = new LinkedList&lt;NestedInteger&gt;(nestedList);</span></span><br><span class="line"><span class="comment">//         while(queue.size() &gt; 0)&#123;</span></span><br><span class="line"><span class="comment">//             int size = queue.size();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             for(int i = 0; i &lt; size; i++)&#123;</span></span><br><span class="line"><span class="comment">//                 NestedInteger ni = queue.poll();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//                 if(ni.isInteger())&#123;</span></span><br><span class="line"><span class="comment">//                     sum += ni.getInteger() * level;</span></span><br><span class="line"><span class="comment">//                 &#125;else&#123;</span></span><br><span class="line"><span class="comment">//                     queue.addAll(ni.getList());</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             level++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return sum;</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper</span><span class="params">(List&lt;NestedInteger&gt; list, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(NestedInteger num: list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(num.isInteger()) sum += depth * num.getInteger();</span><br><span class="line">            <span class="keyword">else</span> sum += helper(num.getList(), depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS recursive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 684 - Redundant Connection</title>
      <link href="/11/22/2019/684/"/>
      <url>/11/22/2019/684/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UnionFindSet</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time Time Complexity: O(N * alpha(N)) ≈ O(N),  Space Complexity: O(N).</span></span><br><span class="line">        <span class="comment">//where N is the number of vertices (and also the number of edges) in the graph, and alpha is the Inverse-Ackermann function</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] parents_;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] ranks_;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">UnionFindSet</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">            parents_ = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            ranks_ = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">//at first, parent of one node is it self</span></span><br><span class="line">                parents_[i] = i;</span><br><span class="line">                ranks_[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> uRoot = Find(u);</span><br><span class="line">            <span class="keyword">int</span> vRoot = Find(v);</span><br><span class="line">            <span class="keyword">if</span> (uRoot == vRoot) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">//union by rank, flat the tree</span></span><br><span class="line">            <span class="keyword">if</span> (ranks_[vRoot] &gt; ranks_[uRoot])</span><br><span class="line">                <span class="comment">//meege pu into pv</span></span><br><span class="line">                parents_[uRoot] = vRoot;           </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ranks_[uRoot] &gt; ranks_[vRoot])</span><br><span class="line">                parents_[vRoot] = uRoot;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// break tie, rank++</span></span><br><span class="line">                parents_[vRoot] = uRoot;</span><br><span class="line">                ranks_[uRoot]++;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// //when parents_[u] == u, u it self is a root</span></span><br><span class="line">            <span class="comment">// while (parents_[u] != u) &#123;</span></span><br><span class="line">            <span class="comment">//     //path compression while finding the root</span></span><br><span class="line">            <span class="comment">//     parents_[u] = parents_[parents_[u]];</span></span><br><span class="line">            <span class="comment">//     u = parents_[u];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// return u;</span></span><br><span class="line">            <span class="keyword">if</span> (u != parents_[u]) &#123;</span><br><span class="line">                parents_[u] = Find(parents_[u]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//must be parents_[u] not u</span></span><br><span class="line">            <span class="keyword">return</span> parents_[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        UnionFindSet s = <span class="keyword">new</span> UnionFindSet(edges.length);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges)</span><br><span class="line">            <span class="keyword">if</span> (!s.Union(edge[<span class="number">0</span>], edge[<span class="number">1</span>]))</span><br><span class="line">                <span class="keyword">return</span> edge;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Union-Find </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 373 - Find K Pairs with Smallest Sums</title>
      <link href="/11/21/2019/373/"/>
      <url>/11/21/2019/373/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//not easy to understand</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation</span></span><br><span class="line">    <span class="comment">// public List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(int[] nums1, int[] nums2, int k) &#123;</span></span><br><span class="line">    <span class="comment">//     PriorityQueue&lt;int[]&gt; que = new PriorityQueue&lt;&gt;((a,b)-&gt;a[0]+a[1]-b[0]-b[1]);</span></span><br><span class="line">    <span class="comment">//     List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     if(nums1.length==0 || nums2.length==0 || k==0) return res;</span></span><br><span class="line">    <span class="comment">//     for(int i=0; i&lt;nums1.length &amp;&amp; i&lt;k; i++) que.offer(new int[]&#123;nums1[i], nums2[0], 0&#125;);</span></span><br><span class="line">    <span class="comment">//     while(k-- &gt; 0 &amp;&amp; !que.isEmpty())&#123;</span></span><br><span class="line">    <span class="comment">//         int[] cur = que.poll();</span></span><br><span class="line">    <span class="comment">//         res.add(new ArrayList&lt;Integer&gt;(Arrays.asList(cur[0], cur[1])));</span></span><br><span class="line">    <span class="comment">//         if(cur[2] == nums2.length-1) continue;</span></span><br><span class="line">    <span class="comment">//         que.offer(new int[]&#123;cur[0],nums2[cur[2]+1], cur[2]+1&#125;);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//pretty much the same idea: 378</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; kSmallestPairs(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (nums1.length == <span class="number">0</span> || nums2.length == <span class="number">0</span>) <span class="keyword">return</span> res;<span class="comment">//[],[],5 case</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; nums1[a[<span class="number">0</span>]] + nums2[a[<span class="number">1</span>]] - nums1[b[<span class="number">0</span>]] - nums2[b[<span class="number">1</span>]]);</span><br><span class="line">        queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pair = queue.poll();</span><br><span class="line">            </span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(Arrays.asList(nums1[pair[<span class="number">0</span>]], nums2[pair[<span class="number">1</span>]])));</span><br><span class="line">            </span><br><span class="line">            c++;</span><br><span class="line">            <span class="keyword">if</span> (c == k || c == nums1.length * nums2.length) <span class="keyword">break</span>;<span class="comment">// k &gt; nums1.length * nums2.length case</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//只有在第一行才向右加。</span></span><br><span class="line">            <span class="comment">//两个原因：1.避免重复加 </span></span><br><span class="line">            <span class="comment">//2.当5被poll出来时，5下面的12是一个candidate, 10下面，5右边的11不是，因为10已经在que里，10下面的数都比10大，所以不用入que</span></span><br><span class="line">            <span class="comment">//            1  10 12     </span></span><br><span class="line">            <span class="comment">//            5  11 13</span></span><br><span class="line">            <span class="comment">//            12 13 15</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pair[<span class="number">0</span>] == <span class="number">0</span> &amp;&amp; pair[<span class="number">1</span>] + <span class="number">1</span> &lt; nums2.length) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>, pair[<span class="number">1</span>] + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pair[<span class="number">0</span>] + <span class="number">1</span> &lt; nums1.length) &#123;</span><br><span class="line">                queue.offer(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;pair[<span class="number">0</span>] + <span class="number">1</span>, pair[<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BinarySearch Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 378 - Kth Smallest Element in a Sorted Matrix</title>
      <link href="/11/21/2019/378/"/>
      <url>/11/21/2019/378/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     The lo we returned is guaranteed to be an element in the matrix is because:</span></span><br><span class="line"><span class="comment">// Let us assume element m is the kth smallest number in the matrix, and x is the number of element m in the matrix. </span></span><br><span class="line"><span class="comment">// When we are about to reach convergence, if mid=m-1, its count value (the number of elements which are &lt;= mid) would be k-x, so we would set lo as (m-1)+1=m, in this case the hi will finally reach lo; and if mid=m+1, its count value would be k+x-1, so we would set hi as m+1, in this case the lo will finally reach m.</span></span><br><span class="line"><span class="comment">// To sum up, because the number lo found by binary search find is exactly the element which has k number of elements in the matrix that are &lt;= lo, The equal sign guarantees there exists and only exists one number in range satisfying this condition. So lo must be the only element satisfying this element in the matrix.</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time: (m+n) * log(max - min), </span></span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> lo = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> hi = matrix[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//how many numbers smaller than mid </span></span><br><span class="line">            <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; matrix[i][j] &gt; mid) &#123;</span><br><span class="line">                    j--;</span><br><span class="line">                &#125;</span><br><span class="line">                count += j + <span class="number">1</span>; <span class="comment">// if j = -1, j + 1 = 0</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">//  time: klogk</span></span><br><span class="line"><span class="comment">//     public int kthSmallest(final int[][] matrix, int k) &#123;</span></span><br><span class="line"><span class="comment">//         int c = 0;</span></span><br><span class="line"><span class="comment">//         PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(</span></span><br><span class="line"><span class="comment">//             k, (o1, o2) -&gt; matrix[o1[0]][o1[1]] - matrix[o2[0]][o2[1]]);</span></span><br><span class="line"><span class="comment">//         queue.offer(new int[] &#123;0, 0&#125;);</span></span><br><span class="line"><span class="comment">//         while (true) &#123;</span></span><br><span class="line"><span class="comment">//             int[] pair = queue.poll();</span></span><br><span class="line"><span class="comment">//             if (++c == k) &#123;</span></span><br><span class="line"><span class="comment">//                 return matrix[pair[0]][pair[1]];</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if (pair[0] == 0 &amp;&amp; pair[1] + 1 &lt; matrix[0].length) &#123;</span></span><br><span class="line"><span class="comment">//                 queue.offer(new int[] &#123;0, pair[1] + 1&#125;);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if (pair[0] + 1 &lt; matrix.length) &#123;</span></span><br><span class="line"><span class="comment">//                 queue.offer(new int[] &#123;pair[0] + 1, pair[1]&#125;);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BinarySearch Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 23 - Merge k Sorted Lists</title>
      <link href="/11/21/2019/23/"/>
      <url>/11/21/2019/23/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(Nlogk) where k is the number of linked lists.   </span></span><br><span class="line">    <span class="comment">//space   O(n) Creating a new linked list costs O(n) space.(如果输出不算数，sapce是O(k),因为heap大小是k)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public ListNode mergeKLists(ListNode[] lists) &#123;</span></span><br><span class="line"><span class="comment">//         if (lists == null || lists.length == 0) return null;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Queue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, new Comparator&lt;ListNode&gt;() &#123;</span></span><br><span class="line"><span class="comment">//             @Override</span></span><br><span class="line"><span class="comment">//             public int compare(ListNode l1, ListNode l2) &#123;</span></span><br><span class="line"><span class="comment">//                 return l1.val - l2.val;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         //Queue&lt;ListNode&gt; minHeap = new PriorityQueue&lt;&gt;(lists.length, (a,b) -&gt; a.val - b.val);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         for (ListNode node: lists) &#123;</span></span><br><span class="line"><span class="comment">//             if (node != null)</span></span><br><span class="line"><span class="comment">//                 minHeap.add(node);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         ListNode dummy = new ListNode(0);</span></span><br><span class="line"><span class="comment">//         ListNode cur = dummy;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         while (!minHeap.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             cur.next = minHeap.poll();</span></span><br><span class="line"><span class="comment">//             cur = cur.next;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//             if (cur.next != null) &#123;</span></span><br><span class="line"><span class="comment">//                 minHeap.add(cur.next);</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         return dummy.next;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Time complexity : O(Nlogk) where k is the number of linked lists.  N (average length * k)is the total number of nodes.</span></span><br><span class="line">    <span class="comment">//merge takes O(N) time and partition takes O(logk) time</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pace   O(n) (如果输出不算数，sapce是O(logk) 因为partition stack高度是logk)</span></span><br><span class="line"><span class="comment">// merge two sorted linked lists take O(1) space. (recursive: logn, iterative：1)</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> partition(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">partition</span><span class="params">(ListNode[] lists, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s == e) &#123;</span><br><span class="line">           <span class="keyword">return</span> lists[s];</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s &lt; e) &#123;</span><br><span class="line">           <span class="keyword">int</span> mid = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">           ListNode l1 = partition(lists, mid + <span class="number">1</span>, e); <span class="comment">// space logk</span></span><br><span class="line">           ListNode l2 = partition(lists, s, mid);</span><br><span class="line">           <span class="keyword">return</span> merge2(l1, l2);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//recursive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = merge(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = merge(l2.next, l1);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//iterative</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">merge2</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode dummy = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 == <span class="keyword">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode LinkedList Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 207 - Course Schedule</title>
      <link href="/11/20/2019/207/"/>
      <url>/11/20/2019/207/</url>
      
        <content type="html"><![CDATA[<p>Basic idea: </p><ul><li>return value of dfs means weather there is a circle in the graph or not.</li><li>visited make sure you won’t visit back.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runtime: 6 ms</span></span><br><span class="line"><span class="comment">// HashMap is slower than ArrayList in this problem.</span></span><br><span class="line"><span class="comment">// topological sort with DFS </span></span><br><span class="line"><span class="comment">// O(V + E) time and O(V + E) space  V:vertex E:edge</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;        </span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];            </span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//determine whether there is a circle in schedule</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//1, visiting</span></span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//2，visited</span></span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//go through all it's neighbors (prerequisites)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited)) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//true means there is circle, because we encountered a visiting point</span></span><br><span class="line">        </span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Graph DFS BFS Topological-Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 210 - Course Schedule II</title>
      <link href="/11/20/2019/210/"/>
      <url>/11/20/2019/210/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Runtime: 83 ms</span></span><br><span class="line"><span class="comment">//topological sort with dfs</span></span><br><span class="line"><span class="comment">//Time complexity: O(V+E)   vertexs and edges</span></span><br><span class="line"><span class="comment">//Space complexity: O(V+E)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            graph.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisites.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> course = prerequisites[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> prerequisite = prerequisites[i][<span class="number">1</span>];</span><br><span class="line">            graph.get(course).add(prerequisite);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i)</span><br><span class="line">            <span class="keyword">if</span> (dfs(i, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];<span class="comment">//is there is circle, return []       </span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[ans.size()];</span><br><span class="line">        <span class="comment">// ans.toArray(res); // fill the array, only used for ref type</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ans.size(); i++) res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr, ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="keyword">int</span>[] visited, List&lt;Integer&gt; ans)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//1:visiting, return true, because we meet a point that still in "visiting" pool, so there is a circle</span></span><br><span class="line">        <span class="keyword">if</span> (visited[curr] == <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//2:visited</span></span><br><span class="line">        visited[curr] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> next : graph.get(curr))</span><br><span class="line">            <span class="keyword">if</span> (dfs(next, graph, visited, ans)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        visited[curr] = <span class="number">2</span>;</span><br><span class="line">        ans.add(curr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Graph DFS BFS Topological-Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 310 - Minimum Height Trees</title>
      <link href="/11/19/2019/310/"/>
      <url>/11/19/2019/310/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// sample 11 ms submission</span></span><br><span class="line">    <span class="comment">//O(n) time O(n) space</span></span><br><span class="line">    <span class="comment">//BFS from perimeter to center</span></span><br><span class="line">    <span class="comment">//The root can be middle n/2 if n is odd or middle two elements if n is even. </span></span><br><span class="line">    <span class="comment">//Only then height can be minimum. Think of it as median of array.</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findMinHeightTrees</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//this is needed...since when there is only 1 vertex... the indegree of it will be 0..this case is not included in the following discussion...</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt;[] graph = (ArrayList&lt;Integer&gt;[]) <span class="keyword">new</span> ArrayList[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] e : edges) &#123;</span><br><span class="line">            graph[e[<span class="number">0</span>]].add(e[<span class="number">1</span>]);</span><br><span class="line">            graph[e[<span class="number">1</span>]].add(e[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] indegree = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> cnt = n;</span><br><span class="line">        Queue&lt;Integer&gt; leaves = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            indegree[i] = graph[i].size();</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                leaves.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (cnt &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = leaves.size();</span><br><span class="line">            cnt -= size;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = leaves.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> w : graph[v]) &#123;</span><br><span class="line">                    indegree[w]--;</span><br><span class="line">                    <span class="keyword">if</span> (indegree[w] == <span class="number">1</span>) &#123;</span><br><span class="line">                        leaves.add(w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="comment">// or</span></span><br><span class="line">    <span class="comment">// while (!q.isEmpty()) &#123;</span></span><br><span class="line">    <span class="comment">//         List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//         int size = q.size();</span></span><br><span class="line">    <span class="comment">//         for (int i = 0; i &lt; size; i++) &#123;</span></span><br><span class="line">    <span class="comment">//             int cur = q.poll();</span></span><br><span class="line">    <span class="comment">//             list.add(cur);</span></span><br><span class="line">    <span class="comment">//             for (int parent : map.get(cur)) &#123;</span></span><br><span class="line">    <span class="comment">//                 degree[parent]--;</span></span><br><span class="line">    <span class="comment">//                 if (degree[parent]== 1) &#123;</span></span><br><span class="line">    <span class="comment">//                     q.offer(parent);</span></span><br><span class="line">    <span class="comment">//                 &#125;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         res = list;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">        res.addAll(leaves);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 482 - License Key Formatting</title>
      <link href="/11/19/2019/482/"/>
      <url>/11/19/2019/482/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">licenseKeyFormatting</span><span class="params">(String S, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = S.length()-<span class="number">1</span>; i&gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (S.charAt(i) != <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">0</span> &amp;&amp; len % K == <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">'-'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> cur = S.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= cur &amp;&amp; <span class="string">'z'</span> &gt;= cur) cur = (<span class="keyword">char</span>)(cur - (<span class="string">'a'</span> - <span class="string">'A'</span>));</span><br><span class="line">                sb.append(cur);</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">        <span class="comment">//or add toUpperCase() at end</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 767 - Reorganize String</title>
      <link href="/11/18/2019/767/"/>
      <url>/11/18/2019/767/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(N) time</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reorganizeString</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); i++) &#123;</span><br><span class="line">            hash[S.charAt(i) - <span class="string">'a'</span>]++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>, letter = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hash[i] &gt; max) &#123;</span><br><span class="line">                max = hash[i];</span><br><span class="line">                letter = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (max &lt; (S.length() + 1) / 2), there must be at least one solution</span></span><br><span class="line">        <span class="keyword">if</span> (max &gt; (S.length() + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] res = <span class="keyword">new</span> <span class="keyword">char</span>[S.length()];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (hash[letter] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res[idx] = (<span class="keyword">char</span>) (letter + <span class="string">'a'</span>);</span><br><span class="line">            idx += <span class="number">2</span>;</span><br><span class="line">            hash[letter]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hash.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (hash[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//here we just pick up what we left and keep going until idx &gt;= res.length, reset idx to 1</span></span><br><span class="line">                <span class="keyword">if</span> (idx &gt;= res.length) &#123;</span><br><span class="line">                    idx = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                res[idx] = (<span class="keyword">char</span>) (i + <span class="string">'a'</span>);</span><br><span class="line">                idx += <span class="number">2</span>;</span><br><span class="line">                hash[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Counter String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1019 - Next Greater Node In Linked List</title>
      <link href="/11/18/2019/1019/"/>
      <url>/11/18/2019/1019/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextLargerNodes(ListNode head) &#123;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (ListNode node = head; node != <span class="keyword">null</span>; node = node.next)</span><br><span class="line">            list.add(node.val);</span><br><span class="line">      </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//go backward</span></span><br><span class="line">        <span class="comment">//store the value in the stack</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// for (int i = list.size() - 1; i &gt;= 0; --i) &#123;</span></span><br><span class="line">        <span class="comment">//     while (!s.isEmpty() &amp;&amp; s.peek() &lt;= list.get(i)) &#123;</span></span><br><span class="line">        <span class="comment">//         s.pop();</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     if (s.isEmpty()) &#123;</span></span><br><span class="line">        <span class="comment">//         res[i] = 0;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         res[i] = s.peek();</span></span><br><span class="line">        <span class="comment">//     &#125;;</span></span><br><span class="line">        <span class="comment">//     s.push(list.get(i));</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//go upward</span></span><br><span class="line">        <span class="comment">//store the index in the stack</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">             <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; list.get(i) &gt; list.get(s.peek())) &#123;</span><br><span class="line">                res[s.pop()] = list.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack LinkedList </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 222 - Count Complete Tree Nodes</title>
      <link href="/11/18/2019/222/"/>
      <url>/11/18/2019/222/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNodes</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// return helper(root);</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper2(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//space: both O(nass)</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(n) time</span></span><br><span class="line">    <span class="comment">// public int helper(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     if (root == null) return 0;</span></span><br><span class="line">    <span class="comment">//     int left = helper(root.left);</span></span><br><span class="line">    <span class="comment">//     int right = helper(root.right);</span></span><br><span class="line">    <span class="comment">//     return left + right + 1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// time complexity (logn) * (logn), = h*h </span></span><br><span class="line">    <span class="comment">//in every level, there will always be one left or right subtree is a complete tree and will just return. </span></span><br><span class="line">    <span class="comment">// So every level's time is O(logn), total time complexity is O(long ^ 2)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">helper2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = getDepth(root.left, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> rightDepth = getDepth(root.right, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == rightDepth) &#123;</span><br><span class="line">           <span class="keyword">return</span>  (<span class="keyword">int</span>)Math.pow(<span class="number">2</span>, leftDepth + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> helper2(root.left) + helper2(root.right) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getDepth</span><span class="params">(TreeNode root, <span class="keyword">boolean</span> isLeft)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = isLeft ? getDepth(root.left, isLeft) + <span class="number">1</span> : getDepth(root.right, isLeft) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree complete-tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 527 - Subtree of Another Tree</title>
      <link href="/11/16/2019/527/"/>
      <url>/11/16/2019/527/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两种算法，第一种写起来简单，时间复杂度不够优秀，第二种需要自己实现一个kmp算法？还是直接用java的contains(n^2复杂度)？</span></span><br><span class="line">    <span class="comment">// n nodes in s, m nodes in t</span></span><br><span class="line">    <span class="comment">//Time complexity : O(m*n). In worst case(skewed tree) traverse function takes O(m*n) time.</span></span><br><span class="line">    <span class="comment">//Space complexity : O(n). The depth of the recursion tree can go upto n. nn refers to the number of nodes in s.</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         return traverse(s, t);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     public boolean traverse(TreeNode s, TreeNode t) &#123;</span></span><br><span class="line"><span class="comment">//         return s!= null &amp;&amp; (isSame(s, t) || traverse(s.left, t) || traverse(s.right, t));</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public boolean isSame (TreeNode t1, TreeNode t2) &#123;</span></span><br><span class="line"><span class="comment">//         if (t1 == null &amp;&amp; t2 == null) return true;</span></span><br><span class="line"><span class="comment">//         if (t1 == null || t2 == null) return false;</span></span><br><span class="line"><span class="comment">//         return t1.val == t2.val &amp;&amp; isSame(t1.left, t2.left) &amp;&amp; isSame(t1.right, t2.right);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Time complexity : O(m + n). space: O(h)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//can only use preOrder here because inorder may 0142  142,  post order may #2#  ##2</span></span><br><span class="line">        <span class="keyword">return</span> serialize(s).contains(serialize(t)); </span><br><span class="line">        <span class="comment">// Java uses a naive contains algorithm so to ensure linear time, </span></span><br><span class="line">        <span class="comment">// replace with KMP algorithm</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, res);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode cur, StringBuilder res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="keyword">null</span>) &#123;res.append(<span class="string">",#"</span>); <span class="keyword">return</span>;&#125;     <span class="comment">//ex:[12],[2] -&gt; ,12,#,#   ,2,#,#   so we must have separator</span></span><br><span class="line">        </span><br><span class="line">        res.append(<span class="string">","</span> + cur.val);</span><br><span class="line">        serialize(cur.left, res);</span><br><span class="line">        serialize(cur.right, res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree Serialization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 105 - Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link href="/11/16/2019/105/"/>
      <url>/11/16/2019/105/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> helper(map, preorder, <span class="number">0</span>, inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">helper</span><span class="params">(Map&lt;Integer, Integer&gt; map, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span> r, <span class="keyword">int</span>[] inorder, <span class="keyword">int</span> s, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s &gt; e) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> val = preorder[r];</span><br><span class="line">        <span class="keyword">int</span> index = map.get(val);</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        root.left = helper(map, preorder, r + <span class="number">1</span>, inorder, s, index - <span class="number">1</span>);</span><br><span class="line">        root.right = helper(map, preorder, r + <span class="number">1</span> + index - s, inorder, index + <span class="number">1</span>, e); <span class="comment">// (index - s) is the size of the cur left tree </span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree DFS Preorder Inorder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 90 - Subsets II (duplicates allowed in nums)</title>
      <link href="/11/13/2019/90/"/>
      <url>/11/13/2019/90/</url>
      
        <content type="html"><![CDATA[<p>Sort needed to deduplicate.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// List&lt;List&lt;Integer&gt;&gt; list = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// Arrays.sort(nums);</span></span><br><span class="line">        <span class="comment">// backtrack(list, new ArrayList&lt;&gt;(), nums, 0);</span></span><br><span class="line">        <span class="comment">// return list;</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || nums[i] != nums[i - <span class="number">1</span>]) begin = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> size = result.size();<span class="comment">//when adding to the list the size is changing so we need get a fixed size first</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = begin; j &lt; size; j++) &#123;</span><br><span class="line">                List&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(result.get(j));</span><br><span class="line">                tempList.add(nums[i]);</span><br><span class="line">                result.add(tempList);</span><br><span class="line">            &#125;</span><br><span class="line">            begin = size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; list , List&lt;Integer&gt; tempList, <span class="keyword">int</span> [] nums, <span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> ArrayList&lt;&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i - <span class="number">1</span>] == nums[i]) <span class="keyword">continue</span>;<span class="comment">//skip the duplicate</span></span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtrack(list, tempList, nums, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 78 - Subsets</title>
      <link href="/11/13/2019/78/"/>
      <url>/11/13/2019/78/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time: n * 2^n bvn</span></span><br><span class="line">    <span class="comment">//for each number we can choose or not choose it.</span></span><br><span class="line">    <span class="comment">//the res.add(new ArrayList&lt;Integer&gt;(tempList)); is O(n)</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">// backtracking(nums, res, new ArrayList&lt;Integer&gt;(), 0);</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n: nums) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = result.size();<span class="comment">//when adding to the list the size is changing so we need get a fixed size first</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                List&lt;Integer&gt; tempList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;(result.get(i));</span><br><span class="line">                tempList.add(n);</span><br><span class="line">                result.add(tempList);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="keyword">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; tempList, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(tempList));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempList.add(nums[i]);</span><br><span class="line">            backtracking(nums, res, tempList, i + <span class="number">1</span>);</span><br><span class="line">            tempList.remove(tempList.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 224 - Climbing Stairs</title>
      <link href="/11/13/2019/70/"/>
      <url>/11/13/2019/70/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// if (n == 1) &#123;</span></span><br><span class="line">        <span class="comment">//     return 1;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// int[] dp = new int[n + 1];</span></span><br><span class="line">        <span class="comment">// dp[1] = 1;</span></span><br><span class="line">        <span class="comment">// dp[2] = 2;</span></span><br><span class="line">        <span class="comment">// for (int i = 3; i &lt;= n; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[i] = dp[i - 1] + dp[i - 2];</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[n];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time O(N), space O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> dp1 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> dp2 = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = dp2;</span><br><span class="line">            dp2 = dp1 + dp2;</span><br><span class="line">            dp1 = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp2;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Fibonacci Formula</span></span><br><span class="line">        <span class="comment">//time O(logN), space O(1)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// double sqrt5=Math.sqrt(5);</span></span><br><span class="line">        <span class="comment">// double fibn=Math.pow((1+sqrt5)/2,n+1)-Math.pow((1-sqrt5)/2,n+1);</span></span><br><span class="line">        <span class="comment">// return (int)(fibn/sqrt5);</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Fibonacci </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 224 - Shortest Distance from All Buildings</title>
      <link href="/11/12/2019/317/"/>
      <url>/11/12/2019/317/</url>
      
        <content type="html"><![CDATA[<p>Basically, we need have 2 int[][] caches for reach and distance, only when reach[i][j] == buildingNum (which means a point can reach to every building), we compare the distance(sum of distance from this point to all reachable buildings) and get the shortest distance.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(m^2n^2)</span></span><br><span class="line">     <span class="comment">//count sum of distance from 0 to all building</span></span><br><span class="line">    <span class="keyword">int</span>[][] distance;</span><br><span class="line">    <span class="comment">//count how many building each '0' can be reached</span></span><br><span class="line">    <span class="keyword">int</span>[][] reach;</span><br><span class="line">    <span class="keyword">int</span>[][] dirs = <span class="keyword">new</span> <span class="keyword">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;, &#123;<span class="number">0</span>,-<span class="number">1</span>&#125;, &#123;-<span class="number">1</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="keyword">null</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m  = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        distance = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        reach = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> buildingNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    buildingNum++;</span><br><span class="line">                    bfs(grid,i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> shortest = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span> &amp;&amp; reach[i][j] == buildingNum) &#123;</span><br><span class="line">                    shortest = Math.min(shortest, distance[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shortest == Integer.MAX_VALUE ? -<span class="number">1</span> : shortest;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span>[][] grid,<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m  = grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; q = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">        q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x, y&#125;);</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> level=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] curr = q.poll();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span>[] dir: dirs)&#123;</span><br><span class="line">                    <span class="keyword">int</span> x1=dir[<span class="number">0</span>] + curr[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">int</span> y1=dir[<span class="number">1</span>] + curr[<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(x1 &lt; <span class="number">0</span> || x1 &gt;= m || y1 &lt; <span class="number">0</span>||y1 &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span>(grid[x1][y1] != <span class="number">0</span> || visited[x1][y1]) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="comment">//find next 0: level++;</span></span><br><span class="line">                    distance[x1][y1] += level;</span><br><span class="line">                    reach[x1][y1]++;</span><br><span class="line">                    visited[x1][y1] = <span class="keyword">true</span>;</span><br><span class="line">                    q.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;x1, y1&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 398 - Random Pick Index</title>
      <link href="/11/12/2019/398/"/>
      <url>/11/12/2019/398/</url>
      
        <content type="html"><![CDATA[<p>Check the second answer <a href="https://leetcode.com/problems/random-pick-index/discuss/88072/Simple-Reservoir-Sampling-solution" target="_blank" rel="noopener">link</a> why the possibility is the same.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// O(1) time space init, O(n) pick</span></span><br><span class="line">    <span class="comment">// another one with O(logn) pick  (pre-sorted(nlogn Time) solution)  but will take O(n) space</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;</span><br><span class="line">    <span class="keyword">private</span> Random random;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Solution</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nums = nums;</span><br><span class="line">        <span class="keyword">this</span>.random = <span class="keyword">new</span> Random();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pick</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != target) <span class="keyword">continue</span>;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (random.nextInt(count) == <span class="number">0</span>) &#123;</span><br><span class="line">                res = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your Solution object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * Solution obj = new Solution(nums);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.pick(target);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode reservoir-sampling </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 224 - Basic Calculator</title>
      <link href="/11/12/2019/224/"/>
      <url>/11/12/2019/224/</url>
      
        <content type="html"><![CDATA[<p>Second solution is easier to understand.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     public int calculate(String s) &#123;</span></span><br><span class="line"><span class="comment">//         if(s == null) return 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         int result = 0;</span></span><br><span class="line"><span class="comment">//         int sign = 1;</span></span><br><span class="line"><span class="comment">//         int num = 0;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         //context sign will be stored in the stack</span></span><br><span class="line"><span class="comment">//         Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         stack.push(sign);//initial as positive</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; s.length(); i++) &#123;</span></span><br><span class="line"><span class="comment">//             char c = s.charAt(i);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             if(c &gt;= '0' &amp;&amp; c &lt;= '9') &#123;</span></span><br><span class="line"><span class="comment">//                 num = num * 10 + (c - '0');</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             &#125; else if(c == '+' || c == '-') &#123;</span></span><br><span class="line"><span class="comment">//                 result += sign * num; </span></span><br><span class="line"><span class="comment">//                 sign = stack.peek() * (c == '+' ? 1: -1);  //case -(4+5),    get all context sign</span></span><br><span class="line"><span class="comment">//                 num = 0;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             &#125; else if(c == '(') &#123;</span></span><br><span class="line"><span class="comment">//                 stack.push(sign);//context sign</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//             &#125; else if(c == ')') &#123;</span></span><br><span class="line"><span class="comment">//                 stack.pop();//pre context sign no longer needed</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         result += sign * num;</span></span><br><span class="line"><span class="comment">//         return result;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Character&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray()) q.offer(c);</span><br><span class="line">        q.offer(<span class="string">'+'</span>);</span><br><span class="line">        <span class="keyword">return</span> cal(q);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">cal</span><span class="params">(Queue&lt;Character&gt; q)</span></span>&#123;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">char</span> cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span>(cur == <span class="string">' '</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(cur))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + (cur - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(cur == <span class="string">'('</span>)</span><br><span class="line">                    num = cal(q);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</span><br><span class="line">                        stack.push(num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;</span><br><span class="line">                        stack.push(-num);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sign = cur;</span><br><span class="line">                    num = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(cur == <span class="string">')'</span>) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) sum += stack.pop();</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 227 - Basic Calculator II</title>
      <link href="/11/12/2019/227/"/>
      <url>/11/12/2019/227/</url>
      
        <content type="html"><![CDATA[<p>follow up: use constant space.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n)</span></span><br><span class="line">    <span class="comment">//space O(n)</span></span><br><span class="line">    <span class="comment">//               num</span></span><br><span class="line">    <span class="comment">//          a  *  b  +  c</span></span><br><span class="line">    <span class="comment">//            sign  cur</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculate</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span> sign = <span class="string">'+'</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(s.charAt(i)))&#123;</span><br><span class="line">                num = num * <span class="number">10</span> + s.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>((!Character.isDigit(s.charAt(i)) &amp;&amp; <span class="string">' '</span> != s.charAt(i)) || i == len - <span class="number">1</span>)&#123;<span class="comment">//corner case: last char</span></span><br><span class="line">                <span class="keyword">if</span>(sign == <span class="string">'-'</span>)&#123;<span class="comment">//sign form last round</span></span><br><span class="line">                    stack.push(-num);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'+'</span>)&#123;</span><br><span class="line">                    stack.push(num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() * num);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sign == <span class="string">'/'</span>)&#123;</span><br><span class="line">                    stack.push(stack.pop() / num);</span><br><span class="line">                &#125;</span><br><span class="line">                sign = s.charAt(i);<span class="comment">//cur pointer sign</span></span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i: stack)&#123;</span><br><span class="line">            res += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public int calculate(String s) &#123;</span></span><br><span class="line"><span class="comment">//         if(s == null) return 0;</span></span><br><span class="line"><span class="comment">//         Queue&lt;Character&gt; q = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         for(char c : s.toCharArray()) q.offer(c);</span></span><br><span class="line"><span class="comment">//         q.offer('+');//corner case, append to the end, can be any operator. other wise the last </span></span><br><span class="line"><span class="comment">//         return cal(q);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     private int cal(Queue&lt;Character&gt; q)&#123;</span></span><br><span class="line"><span class="comment">//         char preSign = '+';</span></span><br><span class="line"><span class="comment">//         int preNum = 0;</span></span><br><span class="line"><span class="comment">//         Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         while(!q.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//             char cur = q.poll();</span></span><br><span class="line"><span class="comment">//             if(cur == ' ') continue;</span></span><br><span class="line"><span class="comment">//             if(Character.isDigit(cur))&#123;</span></span><br><span class="line"><span class="comment">//                 preNum = preNum * 10 + (cur - '0');</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             else&#123;</span></span><br><span class="line"><span class="comment">//                 if(preSign == '+')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(preNum);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 if(preSign == '-')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(-preNum);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 if(preSign == '*')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(stack.pop()*preNum);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 if(preSign == '/')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(stack.pop()/preNum);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 preSign = cur;</span></span><br><span class="line"><span class="comment">//                 preNum = 0;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         int sum = 0;</span></span><br><span class="line"><span class="comment">//         while(!stack.isEmpty()) sum+=stack.pop();</span></span><br><span class="line"><span class="comment">//         return sum;int len = s.length();</span></span><br><span class="line"><span class="comment">//         if(s == null || len == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         int num = 0;</span></span><br><span class="line"><span class="comment">//         char sign = '+';</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; len; i++)&#123;</span></span><br><span class="line"><span class="comment">//             if(Character.isDigit(s.charAt(i)))&#123;</span></span><br><span class="line"><span class="comment">//                 num = num * 10 + s.charAt(i) - '0';</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if((!Character.isDigit(s.charAt(i)) &amp;&amp; ' ' != s.charAt(i)) || i == len - 1)&#123;</span></span><br><span class="line"><span class="comment">//                 if(sign == '-')&#123;//sign form last round</span></span><br><span class="line"><span class="comment">//                     stack.push(-num);</span></span><br><span class="line"><span class="comment">//                 &#125; </span></span><br><span class="line"><span class="comment">//                 else if(sign == '+')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(num);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 else if(sign == '*')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(stack.pop() * num);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 else if(sign == '/')&#123;</span></span><br><span class="line"><span class="comment">//                     stack.push(stack.pop() / num);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 sign = s.charAt(i);//cur pointer sign</span></span><br><span class="line"><span class="comment">//                 num = 0;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         int re = 0;</span></span><br><span class="line"><span class="comment">//         for(int i:stack)&#123;</span></span><br><span class="line"><span class="comment">//             re += i;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return re;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//follow up: use constant space</span></span><br><span class="line">    <span class="comment">//store a top, so we don't have to use stack anymore.</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//     public int calculate(String s) &#123;</span></span><br><span class="line"><span class="comment">//         int len = s.length();</span></span><br><span class="line"><span class="comment">//         if(s == null || len == 0) return 0;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         int num = 0;</span></span><br><span class="line"><span class="comment">//         char sign = '+';</span></span><br><span class="line"><span class="comment">//         int top = 0;</span></span><br><span class="line"><span class="comment">//         int res = 0;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; len; i++)&#123;</span></span><br><span class="line"><span class="comment">//             if(Character.isDigit(s.charAt(i)))&#123;</span></span><br><span class="line"><span class="comment">//                 num = num * 10 + s.charAt(i) - '0';</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             if((!Character.isDigit(s.charAt(i)) &amp;&amp; ' ' != s.charAt(i)) || i == len - 1)&#123;// 2 if because we need both at the end of str (i == len - 1)</span></span><br><span class="line"><span class="comment">//                 if(sign == '-')&#123;//sign form last round</span></span><br><span class="line"><span class="comment">//                     res -= num;</span></span><br><span class="line"><span class="comment">//                     top = -num;</span></span><br><span class="line"><span class="comment">//                 &#125; </span></span><br><span class="line"><span class="comment">//                 else if(sign == '+')&#123;</span></span><br><span class="line"><span class="comment">//                     res += num;</span></span><br><span class="line"><span class="comment">//                     top = num;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 else if(sign == '*')&#123;</span></span><br><span class="line"><span class="comment">//                     res -= top;//pop()</span></span><br><span class="line"><span class="comment">//                     res += top * num;</span></span><br><span class="line"><span class="comment">//                     top = top * num;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 else if(sign == '/')&#123;</span></span><br><span class="line"><span class="comment">//                     res -= top;//pop()</span></span><br><span class="line"><span class="comment">//                     res += top / num;</span></span><br><span class="line"><span class="comment">//                     top = top / num;</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//                 sign = s.charAt(i);//cur pointer sign</span></span><br><span class="line"><span class="comment">//                 num = 0;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 74 - Search a 2D Matrix</title>
      <link href="/11/11/2019/74/"/>
      <url>/11/11/2019/74/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// time O(log(m*n)) = O(logm + logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = n * m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> i = mid / n;</span><br><span class="line">            <span class="keyword">int</span> j = mid % n;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Binary-Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 278 - First Bad Version</title>
      <link href="/11/11/2019/278/"/>
      <url>/11/11/2019/278/</url>
      
        <content type="html"><![CDATA[<p>Same as lc34, you can think this question as find a target in an arr with duplicate in it.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The isBadVersion API is defined in the parent class VersionControl.</span></span><br><span class="line"><span class="comment">      boolean isBadVersion(int version); */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = n;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (isBadVersion(mid)) &#123;</span><br><span class="line">                right = mid; <span class="comment">//might be a candidate</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">//left not a candidate</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Binary-Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 791 - Custom Sort String</title>
      <link href="/11/11/2019/791/"/>
      <url>/11/11/2019/791/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">customSortString</span><span class="params">(String S, String T)</span> </span>&#123;</span><br><span class="line">                                <span class="comment">// dict    to be sorted</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time and space O(T.length())</span></span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: T.toCharArray()) count[c - <span class="string">'a'</span>]++;   <span class="comment">// count each char in T.</span></span><br><span class="line">        </span><br><span class="line">        StringBuilder res = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: S.toCharArray()) &#123;                  <span class="comment">// sort chars both in T and S by the order of S.</span></span><br><span class="line">            <span class="keyword">while</span> (count[c - <span class="string">'a'</span>]-- &gt; <span class="number">0</span>) &#123;   </span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: T.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (count[c - <span class="string">'a'</span>]-- &gt; <span class="number">0</span>) &#123;            <span class="comment">// group chars in T but not in S.</span></span><br><span class="line">                res.append(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// what if we what the rest in lexicographicl order?</span></span><br><span class="line">        <span class="comment">// 构建一个abcde...顺序的String，再按这个把剩下的一排就好了</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode String alphabetical-order Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 71 - Simplify Path</title>
      <link href="/11/11/2019/71/"/>
      <url>/11/11/2019/71/</url>
      
        <content type="html"><![CDATA[<p>why you should use deque instead of stack. <a href="https://leetcode.com/problems/flatten-nested-list-iterator/discuss/80147/Simple-Java-solution-using-a-stack-with-explanation/165585" target="_blank" rel="noopener">link</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//we can't use stack here because it's iterator is not reliable</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">for</span>(String cur: path.split(<span class="string">"/"</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.equals(<span class="string">".."</span>) &amp;&amp; !stack.isEmpty()) &#123;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!cur.equals(<span class="string">""</span>) &amp;&amp; !cur.equals(<span class="string">"."</span>) &amp;&amp; !cur.equals(<span class="string">".."</span>)) stack.push(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//reverse</span></span><br><span class="line">        Deque&lt;String&gt; temp = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) temp.push(stack.pop());</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span> (!temp.isEmpty()) &#123;</span><br><span class="line">            sb.append(<span class="string">"/"</span>).append(temp.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.length() == <span class="number">0</span> ? <span class="string">"/"</span> : sb.toString(); <span class="comment">//    "/../"  case, should return "/" instead of ""</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 84 - Largest Rectangle in Histogram</title>
      <link href="/11/10/2019/84/"/>
      <url>/11/10/2019/84/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(<span class="keyword">int</span>[] heights)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n)</span></span><br><span class="line">        <span class="keyword">if</span> (heights == <span class="keyword">null</span> || heights.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = heights.length;</span><br><span class="line">        <span class="keyword">int</span>[] leftFirstSmall = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span>[] rightFirstSmall = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        leftFirstSmall[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        rightFirstSmall[n - <span class="number">1</span>] =  n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                leftFirstSmall[i] = i - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> j = leftFirstSmall[i - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">// while (j &gt;= 0 &amp;&amp; heights[j] &gt;= heights[i]) j--;</span></span><br><span class="line">                <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; heights[j] &gt;= heights[i]) j = leftFirstSmall[j];</span><br><span class="line">                leftFirstSmall[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (heights[i] &gt; heights[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                rightFirstSmall[i] =  i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> j = rightFirstSmall[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//while (j &lt; n &amp;&amp; heights[j] &gt;= heights[i]) j++;</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; heights[j] &gt;= heights[i]) j = rightFirstSmall[j];</span><br><span class="line">                rightFirstSmall[i] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            res = Math.max(res, (rightFirstSmall[i] - leftFirstSmall[i] - <span class="number">1</span>) * heights[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 42 - Trapping Rain Water</title>
      <link href="/11/10/2019/42/"/>
      <url>/11/10/2019/42/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// So, we can say that if there is a larger bar at one end (say right), </span></span><br><span class="line">        <span class="comment">//we are assured that the water trapped would be dependant on height of bar in </span></span><br><span class="line">        <span class="comment">//current direction (from left to right). As soon as we find the bar at other end (right) is smaller, </span></span><br><span class="line">        <span class="comment">//we start iterating in opposite direction (from right to left)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time O(n) space O(1)</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_max = <span class="number">0</span>, right_max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">//depend on the smaller side</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (height[left] &gt;= left_max) &#123;</span><br><span class="line">                    <span class="comment">//update max</span></span><br><span class="line">                    left_max = height[left];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//update value</span></span><br><span class="line">                    ans += (left_max - height[left]) * <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//height[left] &gt;= height[right]</span></span><br><span class="line">                <span class="keyword">if</span> (height[right] &gt;= right_max) &#123;</span><br><span class="line">                    right_max = height[right];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += (right_max - height[right]) * <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time O(n) space O(n)</span></span><br><span class="line"><span class="comment">//          if (height.length &lt;= 2) return 0;</span></span><br><span class="line"><span class="comment">//          int ans = 0;</span></span><br><span class="line"><span class="comment">//          int len = height.length;</span></span><br><span class="line"><span class="comment">//          int[] left_max = new int[len];</span></span><br><span class="line"><span class="comment">//          int[] right_max = new int[len];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          left_max[0] = height[0];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          for (int i = 1; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//             left_max[i] = Math.max(height[i], left_max[i - 1]);</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          right_max[len - 1] = height[len - 1];</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          for (int i = len - 2; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//             right_max[i] = Math.max(height[i], right_max[i + 1]);</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          for (int i = 1; i &lt; len - 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//             ans += Math.min(left_max[i], right_max[i]) - height[i];</span></span><br><span class="line"><span class="comment">//          &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//          return ans;</span></span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (height == null) return 0;</span></span><br><span class="line">        <span class="comment">// Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// int i = 0, maxWater = 0, maxBotWater = 0;</span></span><br><span class="line">        <span class="comment">// while (i &lt; height.length)&#123;</span></span><br><span class="line">        <span class="comment">//     if (s.isEmpty() || height[i] &lt;= height[s.peek()])&#123;</span></span><br><span class="line">        <span class="comment">//         s.push(i++);//only when s is empty or descending....can we add i</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     else &#123;</span></span><br><span class="line">        <span class="comment">//         int bot = s.pop();</span></span><br><span class="line">        <span class="comment">//         maxBotWater = s.isEmpty() ? // empty means no il</span></span><br><span class="line">        <span class="comment">//         0 : (Math.min(height[s.peek()], height[i]) - height[bot]) * (i - s.peek() - 1);</span></span><br><span class="line">        <span class="comment">//         maxWater += maxBotWater;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return maxWater;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 341 - Flatten Nested List Iterator</title>
      <link href="/11/10/2019/341/"/>
      <url>/11/10/2019/341/</url>
      
        <content type="html"><![CDATA[<p>2 ways to solve this problem. </p><ul><li>First is preprocess. The preprocess taek O(n) time and next hasNext take O(1) time.<br>But the space will be O(n)</li><li>Second will use a stack and only iterate the necessary part when next() been called. This solution will save a lot of space. The amortized time for next{} and hasNext() will be O(1)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * public interface NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     public boolean isInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     public Integer getInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // <span class="doctag">@return</span> the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // Return null if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     public List&lt;NestedInteger&gt; getList();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n) preprocess and O(1) next, hasNext</span></span><br><span class="line"><span class="comment">// public class NestedIterator implements Iterator&lt;Integer&gt; &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private List&lt;Integer&gt; flattenedList;</span></span><br><span class="line"><span class="comment">//     private Iterator&lt;Integer&gt; it;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span></span><br><span class="line"><span class="comment">//         flattenedList = new LinkedList&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         flatten(nestedList);</span></span><br><span class="line"><span class="comment">//         it = flattenedList.iterator();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private void flatten(List&lt;NestedInteger&gt; nestedList) &#123;</span></span><br><span class="line"><span class="comment">//         for (NestedInteger i : nestedList) &#123;</span></span><br><span class="line"><span class="comment">//             if (i.isInteger()) &#123;</span></span><br><span class="line"><span class="comment">//                 flattenedList.add(i.getInteger());</span></span><br><span class="line"><span class="comment">//             &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                 flatten(i.getList());</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public Integer next() &#123;</span></span><br><span class="line"><span class="comment">//         return it.next();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public boolean hasNext() &#123;</span></span><br><span class="line"><span class="comment">//         return it.hasNext();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//que version of use a lot space</span></span><br><span class="line"><span class="comment">//     Queue&lt;Integer&gt; q;</span></span><br><span class="line"><span class="comment">//     public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span></span><br><span class="line"><span class="comment">//         q = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         helper(nestedList, q);        </span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     private void helper(List&lt;NestedInteger&gt; list, Queue&lt;Integer&gt; q)&#123;</span></span><br><span class="line"><span class="comment">//         for(NestedInteger n : list)&#123;</span></span><br><span class="line"><span class="comment">//             if(n.isInteger()) q.offer(n.getInteger());</span></span><br><span class="line"><span class="comment">//             else helper(n.getList(),q);            </span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public Integer next() &#123;</span></span><br><span class="line"><span class="comment">//         return hasNext() ? q.poll() : -1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     @Override</span></span><br><span class="line"><span class="comment">//     public boolean hasNext() &#123;</span></span><br><span class="line"><span class="comment">//         return !q.isEmpty();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// use this one to save space ()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;NestedInteger&gt; stack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//seperate excution time into each call, and reduce space complexity(worst still O(n)).</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NestedIterator</span><span class="params">(List&lt;NestedInteger&gt; nestedList)</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        flattenList(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//O(n) worst case</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext() ? stack.pop().getInteger() : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stack.peek().isInteger()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            flattenList(stack.pop().getList());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flattenList</span><span class="params">(List&lt;NestedInteger&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = list.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            stack.push(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Iterator Amortized-Time Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 901 - Online Stock Span</title>
      <link href="/11/10/2019/901/"/>
      <url>/11/10/2019/901/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(n) time, O(n) space</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;<span class="keyword">int</span>[]&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//amortized O(1) each time, O(n) time total(n is the number of calls to next())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek()[<span class="number">0</span>] &lt;= price) &#123;</span><br><span class="line">          res += stack.pop()[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;price, res&#125;);<span class="comment">//the stack here is descending (price)</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 34 - Find First and Last Position of Element in Sorted Array</title>
      <link href="/11/10/2019/34/"/>
      <url>/11/10/2019/34/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = findInsertPostion(nums, target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find where to insert target + 1, then index - 1 to find the last postion of target</span></span><br><span class="line">            <span class="comment">//[1], 1 case, return [0, 0]</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= nums.length || nums[a] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> b = findInsertPostion(nums, target + <span class="number">1</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;a, b - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check question #35 out!// 35不带重复，此题带重复。所以如果这种写法不能保证logN复杂度</span></span><br><span class="line">    <span class="comment">// public int findInsertPostion(int[] nums, int target) &#123;</span></span><br><span class="line">    <span class="comment">//     int lo = 0, hi = nums.length - 1;</span></span><br><span class="line">    <span class="comment">//     while (lo &lt;= hi) &#123;</span></span><br><span class="line">    <span class="comment">//         int mid = lo + (hi - lo) / 2;</span></span><br><span class="line">    <span class="comment">//         if (nums[mid] &gt; target) &#123;</span></span><br><span class="line">    <span class="comment">//             hi = mid - 1;</span></span><br><span class="line">    <span class="comment">//         &#125; else if (nums[mid] &lt; target) &#123;</span></span><br><span class="line">    <span class="comment">//             lo = mid + 1;</span></span><br><span class="line">    <span class="comment">//         &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//             while (mid &gt; 0 &amp;&amp; nums[mid - 1] == nums[mid]) &#123;</span></span><br><span class="line">    <span class="comment">//                 mid--;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             return mid;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return lo;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种情况可以handle带duplicate的情况，注意cornercase不一样</span></span><br><span class="line">    <span class="comment">//this one can handle duplicates in arr, this one return left most pos if duplicates exist.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInsertPostion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//wocao? 为啥要hi = n才能过[1], target 1 case, return [0, 0]</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//nums[mid] &gt;= target</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Search Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 240 - Search a 2D Matrix II</title>
      <link href="/11/10/2019/240/"/>
      <url>/11/10/2019/240/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time complexity O(n + m)</span></span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//follow up: find target (with or without duplicate, use binary search(重复的话就问target一共有多少个))</span></span><br><span class="line"><span class="comment">// if duplicateas are allowed, how many target are there in the matrix?</span></span><br><span class="line"><span class="comment">//use this binary search (check detail in lc 34)</span></span><br><span class="line"><span class="comment">//这种情况可以handle带duplicate的情况，注意cornercase不一样</span></span><br><span class="line"><span class="comment">// public int findInsertPostion(int[] nums, int target) &#123;</span></span><br><span class="line"><span class="comment">//     //wocao? 为啥要hi = n才能过[1], target 1 case, return [0, 0]</span></span><br><span class="line"><span class="comment">//     int lo = 0, hi = nums.length;</span></span><br><span class="line"><span class="comment">//     while (lo &lt; hi) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = lo + (hi - lo) / 2;</span></span><br><span class="line"><span class="comment">//         if (nums[mid] &lt; target) &#123;</span></span><br><span class="line"><span class="comment">//             lo = mid + 1;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             //nums[mid] &gt;= target</span></span><br><span class="line"><span class="comment">//             hi = mid;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return lo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Search Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 739 - Daily Temperatures</title>
      <link href="/11/09/2019/739/"/>
      <url>/11/09/2019/739/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line"><span class="comment">//         Stack&lt;Integer&gt; st = new Stack();</span></span><br><span class="line"><span class="comment">//         int[] res = new int[T.length];</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; T.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             while (!st.isEmpty() &amp;&amp; T[i] &gt; T[st.peek()]) &#123;</span></span><br><span class="line"><span class="comment">//                 int index = st.pop();</span></span><br><span class="line"><span class="comment">//                 res[index] = i - index;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//             st.push(i);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; T[i] &gt;= T[st.peek()]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.isEmpty()) &#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = st.peek() - i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public int[] dailyTemperatures(int[] T) &#123;</span></span><br><span class="line"><span class="comment">//         int[] stack = new int[T.length];</span></span><br><span class="line"><span class="comment">//         int top = -1;</span></span><br><span class="line"><span class="comment">//         int[] ret = new int[T.length];</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; T.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             while(top &gt; -1 &amp;&amp; T[i] &gt; T[stack[top]]) &#123;</span></span><br><span class="line"><span class="comment">//                 int idx = stack[top--];</span></span><br><span class="line"><span class="comment">//                 ret[idx] = i - idx;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             stack[++top] = i;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return ret;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 503 - Next Greater Element II</title>
      <link href="/11/09/2019/503/"/>
      <url>/11/09/2019/503/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; nums[i % n] &gt;= s.peek()) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">                res[i % n] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i % n] = s.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Arrays.fill(res, -1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; n * 2; i++) &#123;</span></span><br><span class="line"><span class="comment">//             int num = nums[i % n]; </span></span><br><span class="line"><span class="comment">//             while (!s.isEmpty() &amp;&amp; nums[s.peek()] &lt; num)</span></span><br><span class="line"><span class="comment">//                 res[s.pop()] = num;</span></span><br><span class="line"><span class="comment">//             //if (i &lt; n) s.push(i);</span></span><br><span class="line"><span class="comment">//             s.push(i % n);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 496 - Next Greater Element I</title>
      <link href="/11/09/2019/496/"/>
      <url>/11/09/2019/496/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//time and space both O(m + n)</span></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums2[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">                map.put(nums2[i], -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums2[i], s.peek());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 91 - Decode Ways</title>
      <link href="/11/09/2019/91/"/>
      <url>/11/09/2019/91/</url>
      
        <content type="html"><![CDATA[<p>Similiar questions:</p><ul><li><ol start="62"><li>Unique Paths</li></ol></li><li><ol start="70"><li>Climbing Stairs</li></ol></li><li><ol start="509"><li>Fibonacci Number</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n) space O(n)      would the input be 0?</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//no string, so only one way -&gt; no solution</span></span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> oneDigit = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> twoDigit = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= oneDigit &amp;&amp; <span class="number">9</span> &gt;= oneDigit) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span> &lt;= twoDigit &amp;&amp; <span class="number">26</span> &gt;= twoDigit) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="comment">//we can get to O(1) space</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.charAt(0) == '0') return 0;</span></span><br><span class="line">        <span class="comment">// // prev1 represents dp[i-2]</span></span><br><span class="line">        <span class="comment">// int prev1 = 1;</span></span><br><span class="line">        <span class="comment">// // prev2 represents dp[i-1]</span></span><br><span class="line">        <span class="comment">// int prev2 = 1;</span></span><br><span class="line">        <span class="comment">// int res = prev2;</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt; s.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     res = 0;</span></span><br><span class="line">        <span class="comment">//     // if prev1 and prev2 are both 0, we can jump out of the loop earlier</span></span><br><span class="line">        <span class="comment">//     if(prev1==0 &amp;&amp; prev2==0) return 0;</span></span><br><span class="line">        <span class="comment">//     if(s.charAt(i) != '0') res += prev2;</span></span><br><span class="line">        <span class="comment">//     int num = Integer.valueOf(s.substring(i-1,i+1));</span></span><br><span class="line">        <span class="comment">//     if(num &gt;= 10 &amp;&amp; num &lt;= 26) res += prev1;</span></span><br><span class="line">        <span class="comment">//     prev1 = prev2;</span></span><br><span class="line">        <span class="comment">//     prev2 = res;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (s.length() == 0 || s == null) return 0;</span></span><br><span class="line">        <span class="comment">// int[] res = new int[s.length()];</span></span><br><span class="line">        <span class="comment">// Arrays.fill(res, - 2); // can be any negative number</span></span><br><span class="line">        <span class="comment">// return decode(s, 0, res);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//time O(n) space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span> <span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span>[] res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= s.length()) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//complete one, return 1</span></span><br><span class="line">        <span class="keyword">if</span> (res[start] != -<span class="number">2</span>) <span class="keyword">return</span> res[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        String oneDigit = s.substring(start, start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (isValid(oneDigit)) &#123;</span><br><span class="line">            count += decode(s, start + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start + <span class="number">2</span> &lt;= s.length()) &#123;</span><br><span class="line">            String twoDigit = s.substring(start, start + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (isValid(twoDigit)) &#123;</span><br><span class="line">                count += decode(s, start + <span class="number">2</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[start] = count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">1</span> &amp;&amp; res &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> String DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 199 - Binary Tree Right Side View</title>
      <link href="/11/09/2019/199/"/>
      <url>/11/09/2019/199/</url>
      
        <content type="html"><![CDATA[<p>You can use recursive(DFS) or BFS to solve this problem.<br>You must master all 2 solutions to pass the interview. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time and space O(n)</span></span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         dfs(root, 0, ans);</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private void dfs(TreeNode root, int level, List&lt;Integer&gt; ans) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (level == ans.size()) &#123;</span></span><br><span class="line"><span class="comment">//             ans.add(root.val);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         dfs(root.right, level + 1, ans);</span></span><br><span class="line"><span class="comment">//         dfs(root.left, level + 1, ans); //still have this because rsv may exist in left branches </span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//time and space O(n)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse level traversal</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.size();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (size == temp - <span class="number">1</span>) result.add(cur.val);<span class="comment">// the first one(start from right)</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tree DFS BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 456 - 132 Pattern</title>
      <link href="/11/08/2019/456/"/>
      <url>/11/08/2019/456/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// time n^2</span></span><br><span class="line">        <span class="comment">// int min_i = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">// for (int j = 0; j &lt; nums.length - 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">//     min_i = Math.min(min_i, nums[j]);</span></span><br><span class="line">        <span class="comment">//     for (int k = j + 1; k &lt; nums.length; k++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (nums[k] &lt; nums[j] &amp;&amp; min_i &lt; nums[k])</span></span><br><span class="line">        <span class="comment">//             return true;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return false;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Time complexity: O(n)</span></span><br><span class="line">        <span class="comment">//Space complexity: O(n) //in worst case, nums is in ascending order</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//index: s1&lt;s3&lt;s2</span></span><br><span class="line">        <span class="keyword">int</span> s2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//since the index of s2 should be the largest, so iterate from the end of the array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; s2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) &#123;<span class="comment">// value: cur &gt; stack.peek()    index: cur &lt; stack.peek()</span></span><br><span class="line">                s2 = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[i]);<span class="comment">//the ele in stack is descending</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 241 - Different Ways to Add Parentheses</title>
      <link href="/11/08/2019/241/"/>
      <url>/11/08/2019/241/</url>
      
        <content type="html"><![CDATA[<p>The dfs <code>return a list</code>.<br>We split the input s by a operator. And dfs with left part and right part, get 2 list res.<br>Those 2 lists will be all the possible res of left and right part.<br>Use 2 lists form a new return list.<br><code>Notice if there is no operator in the input str, you will have to return a list with single number in it</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解题思路：</span></span><br><span class="line"><span class="comment">    使用 DFS 处理。</span></span><br><span class="line"><span class="comment">    1. 在当前层，我们遍历当前层的input string, e.g. x + y,(注意：x 和 y 可能还是复合表达式，不一定只是数字) 每遇到一个运算符后，我们就将 String 拆分成 x 和 y 然后传到下一层。（注意，当前层可能有很多个运算符，出于simplicity 我们的例子才是 x + y，有可能是 x + y * z）</span></span><br><span class="line"><span class="comment">    2. What do we expect from child nodes?</span></span><br><span class="line"><span class="comment">        孩子1 会把 x 这个复合表达式的各种可能位置加括号的运算结果封装到一个 List&lt;Integer&gt; 中返回回来；同理，孩子2 会把 y 这个复合表达式的各种可能位置加括号的运算结果封装到一个 List&lt;Integer&gt; 中返回回来</span></span><br><span class="line"><span class="comment">    3. What will we do at current node?</span></span><br><span class="line"><span class="comment">        因为我们是遇到 “+” 然后把 string 拆分成 x 和 y 的，并且孩子1返回了 x 表达式各种可能的运算结果，孩子2返回了 y 表示式各种可能的运算结果，我们需要组合相加各种 x 和 y的结果，因为当前层拆分的符号是 "+" 号。</span></span><br><span class="line"><span class="comment">    4. What will we return to the parent node？</span></span><br><span class="line"><span class="comment">        在当前层我们每组和相加一种 x 和 y 的结果，就存入 List&lt;Integer&gt; 中，最后返回的就是这个 List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    e.g. </span></span><br><span class="line"><span class="comment">            2 - 1 -1 * 5</span></span><br><span class="line"><span class="comment">    / \         /   \   /      \</span></span><br><span class="line"><span class="comment">   2  1-1*5   2-1  1*5  2-1-1   5</span></span><br><span class="line"><span class="comment">    (-)          (-)         (*)    分割当前String的运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ------Time Complexity = O(n!)-------- 因为每往下一层会少一个运算符. </span></span><br><span class="line"><span class="comment">    假设第 1 层有 n 个运算符，那么第 1 层就有 2n 个分支；第 2 层有 n-1 个运算符，所以第 2 层有 2*(n-1)个分支</span></span><br><span class="line"><span class="comment">    最后一层的分支数量是 2n * 2(n-1) * ... * 2 = 2 * n! = O(n!)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    -------Space Complexity = O(n! + n)--------- // 第二个 n 是 recursion tree's height</span></span><br><span class="line"><span class="comment">    这题和 merge sort 很像。我们可以盯着第1层看，每个运算符符拆分成的两个表达式会从子节点 return 回来结果，但是我们需要在第一层保存这些结果然后扎到另一个分支。当从倒数第二个运算符 return 回来结果后，我们需要保存前面所有的结果，which is O(n!)，然后扎到最后一个运算符的分支，所以 Space = O(n!)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这个 recursion tree 的 depth 应该是 O(n)，因为每一层会减少一个运算符，而运算符的数量是不会超过input string 的长度的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Assumption: </span></span><br><span class="line"><span class="comment">    1. No integer overflow</span></span><br><span class="line"><span class="comment">    2. No divisor</span></span><br><span class="line"><span class="comment">    3. If input is null or empty, return empty list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Time Complexity = O(n!) 因为每往下一层会少一个运算符. </span></span><br><span class="line"><span class="comment">// Space Complexity = O(n! + n) // 第二个 n 是 recursion tree's height</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = findAllResults(input);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find all possible results</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">findAllResults</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; curRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOperator(str.charAt(i))) &#123;</span><br><span class="line">                List&lt;Integer&gt; left = findAllResults(str.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = findAllResults(str.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l: left) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r: right) &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (str.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                            res = l + r;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                            res = l - r;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res = l * r;</span><br><span class="line">                        &#125;</span><br><span class="line">                        curRes.add(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// corner case: no operators, only number</span></span><br><span class="line">        <span class="keyword">if</span> (curRes.size() == <span class="number">0</span>) &#123; </span><br><span class="line">            curRes.add(Integer.valueOf(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curRes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character == <span class="string">'+'</span> || character == <span class="string">'-'</span> || character == <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS Divide-And-Conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1216 - Valid Palindrome III</title>
      <link href="/11/08/2019/1216/"/>
      <url>/11/08/2019/1216/</url>
      
        <content type="html"><![CDATA[<p>Find the longest Palindrome Subsequence.(lc 516)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidPalindrome</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> lps = lps(s);</span><br><span class="line">        <span class="keyword">return</span> (n - lps &lt;= k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    longest palindromic subsequence:(lc 516)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lps</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 354 - Russian Doll Envelopes</title>
      <link href="/11/07/2019/354/"/>
      <url>/11/07/2019/354/</url>
      
        <content type="html"><![CDATA[<p>Use Longest-Increasing-Subsequence to solve this problem.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>] == <span class="keyword">null</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] </span></span><br><span class="line">        <span class="comment">// when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tails[] = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        tails[<span class="number">0</span>] = envelopes[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &lt; tails[<span class="number">0</span>]) &#123;</span><br><span class="line">                tails[<span class="number">0</span>] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; tails[len]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                tails[len] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tails[binarySearch(tails, <span class="number">0</span>, len, envelopes[i][<span class="number">1</span>])] = envelopes[i][<span class="number">1</span>]; <span class="comment">// 1 2 4 6 -&gt; search 3, return idx 2 --update 1 2 3 6</span></span><br><span class="line">                <span class="comment">//[10,9,2,5,3,4] if no binarySearch, res will be 2, but it's 3, BS will 2,5 -&gt; 2,3, update the last element</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] tails, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;<span class="comment">//no duplicate search</span></span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tails[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP binary-search Longest-Increasing-Subsequence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 300 - Longest Increasing Subsequence</title>
      <link href="/11/07/2019/300/"/>
      <url>/11/07/2019/300/</url>
      
        <content type="html"><![CDATA[<p>If you can’t understand the code, check this post <a href="https://segmentfault.com/a/1190000003819886" target="_blank" rel="noopener">link</a></p><p>similar question :lc 354</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n squared time</span></span><br><span class="line"><span class="comment">//         if (nums.length == 0) &#123;</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         int[] dp = new int[nums.length];</span></span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line"><span class="comment">//         int ans = 1;</span></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             int maxval = 0;</span></span><br><span class="line"><span class="comment">//             for (int j = 0; j &lt; i; j++) &#123;</span></span><br><span class="line"><span class="comment">//                 if(nums[i] &gt; nums[j]) &#123;</span></span><br><span class="line"><span class="comment">//                     maxval = Math.max(maxval, dp[j]);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             dp[i] = maxval + 1;</span></span><br><span class="line"><span class="comment">//             ans = Math.max(ans, dp[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// nlogn time</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];<span class="comment">//increasing arr, so we can do binarySearch on it</span></span><br><span class="line">        tails[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; tails[<span class="number">0</span>]) &#123;</span><br><span class="line">                tails[<span class="number">0</span>] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; tails[len]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                tails[len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tails[binarySearch(tails, <span class="number">0</span>, len, nums[i])] = nums[i]; <span class="comment">// 1 2 4 6 -&gt; search 3, return idx 2 --update 1 2 3 6</span></span><br><span class="line">                <span class="comment">//[10,9,2,5,3,4] if no binarySearch, res will be 2, but it's 3, BS will 2,5 -&gt; 2,3, update the last element</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] tails, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tails[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP binary-search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1143 - Longest Common Subsequence</title>
      <link href="/11/07/2019/1143/"/>
      <url>/11/07/2019/1143/</url>
      
        <content type="html"><![CDATA[<p>//516 718 1216 1143 5 those questions are also pretty alike this one.</p><p>In this quetion, i means for s1, range[0, i - 1] and j means for s2, range[0, j - 1]<br>what the Longest Common Subsequence?<br><code>So dp[i][j] means for first i elements in s1 and for first j elements in s2, what the LCS?</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(mn) space O(mn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[0][0], dp[0][j], dp[i][0] all = zero</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] =  Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP Dynamic Programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 516 - Longest Palindromic Subsequence</title>
      <link href="/11/07/2019/516/"/>
      <url>/11/07/2019/516/</url>
      
        <content type="html"><![CDATA[<p>check 680. Valid Palindrome II, lc5, lc1143 for better understanding of this problem.<br>And solution of this question can also been applied to 1216. Valid Palindrome III.</p><p>//516 1216 1143 5 those questions are also pretty alike this one.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//single char itself is a valid palindrome.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//dp[i][j] = dp[i+1][j-1] + 2;// if j-i == 1, [i+1][j-1] will = 0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);<span class="comment">//same as 680. Valid Palindrome II, you can think of you delete letf or right one, and rest have to be a palindrome.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP Dynamic Programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 621 - Task Scheduler</title>
      <link href="/11/06/2019/621/"/>
      <url>/11/06/2019/621/</url>
      
        <content type="html"><![CDATA[<p>The best strategy solving this problem: get max and maxCount, then insert the rest of chars in between.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//The problem actually requires us to make the "distance" between two same tasks up to at least n. </span></span><br><span class="line"><span class="comment">//Thus,if emptySlots is negative, it means that we even have remaining </span></span><br><span class="line"><span class="comment">//tasks to make the "distance" between same tasks longer than n. That is, no idle is needed. Thus,</span></span><br><span class="line"><span class="comment">//idles = Math.max(0, emptySlots - availableTasks); is for covering this case.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(n) time O(1) space</span></span><br><span class="line">    <span class="comment">//need to clearify: is n always valid?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> task : tasks) &#123;</span><br><span class="line">            counter[task - <span class="string">'A'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(max == counter[task - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(max &lt; counter[task - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                max = counter[task - <span class="string">'A'</span>];<span class="comment">//出现最多的task的出现次数是多少(比如A和B都出现3次，max=3）if both A and B show 3 times, max=3</span></span><br><span class="line">                maxCount = <span class="number">1</span>;<span class="comment">//几个出现最多次数的task（比如A和B都出现3次，maxCount=2） if A and B with max 3, maxCount =2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> partCount = max - <span class="number">1</span>;<span class="comment">//A (? ?) A (? ?) A   emptyslots = 3 - 1 = 2, 2 intervals</span></span><br><span class="line">        <span class="keyword">int</span> partLength = n - (maxCount - <span class="number">1</span>);<span class="comment">//A (B ? ?) A (B ? ?) ...,</span></span><br><span class="line">        <span class="comment">//3-(2-1)=2, so there are 2 dile slots per interval</span></span><br><span class="line">        <span class="keyword">int</span> emptySlots = partCount * partLength;<span class="comment">//at least there are these emptySlots</span></span><br><span class="line">        <span class="keyword">int</span> availableTasks = tasks.length - max * maxCount;</span><br><span class="line">        <span class="keyword">int</span> idles = Math.max(<span class="number">0</span>, emptySlots - availableTasks);<span class="comment">//if idels = 0, means no idles needed</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tasks.length + idles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode array math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 51 - N-Queens</title>
      <link href="/11/06/2019/51/"/>
      <url>/11/06/2019/51/</url>
      
        <content type="html"><![CDATA[<p>The original solution using a 2 dimensional arr as temp for backtracking. So the space will be <code>O(n^2)</code><br>I improve the space to <code>O(n)</code> using a single arr. chess[i] = j means at ith row, the chess is on jth col.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n) space(best)     time is factorial, O(N!) time</span></span><br><span class="line"><span class="comment">//backtracking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//backtracking  n*n space if you use this solution:</span></span><br><span class="line">    <span class="comment">//https://leetcode.com/problems/n-queens/discuss/19808/Accepted-4ms-c%2B%2B-solution-use-backtracking-and-bitmask-easy-understand.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//I change to O(n) space myself</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] chess = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(chess, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        solve(res, chess, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span>[] chess, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == chess.length) &#123;</span><br><span class="line">            res.add(construct(chess));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chess.length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(chess, row, col)) &#123;</span><br><span class="line">                chess[row] = col;</span><br><span class="line">                solve(res, chess, row + <span class="number">1</span>);</span><br><span class="line">                chess[row] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span>[] chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (chess[i] == col) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// check all cols</span></span><br><span class="line">          <span class="keyword">if</span> (chess[i] + i == col + row) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 45 degree</span></span><br><span class="line">          <span class="keyword">if</span> (chess[i] - i == col - row) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 135</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] chess)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] temp = <span class="keyword">new</span> <span class="keyword">char</span>[chess.length];</span><br><span class="line">            Arrays.fill(temp, <span class="string">'.'</span>);</span><br><span class="line">            temp[chess[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            path.add(<span class="keyword">new</span> String(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 689 - Maximum Sum of 3 Non-Overlapping Subarrays</title>
      <link href="/11/06/2019/689/"/>
      <url>/11/06/2019/689/</url>
      
        <content type="html"><![CDATA[<p>Facebook follow up question.</p><p>preprocessed sum is for gettting sub-arr sum in O(1) time.</p><p><code>posLeft</code>is used to store left window max’s start index(as we have to return it as res)<br><code>posRight</code>is is used to store right window max’s start index</p><p>At the last iteration, exhaust all the possible middle start point (range from k to n-2*k) and get the res using pre-stored start index.<br>There are many similar questions in leetcode such as <code>max area histogram</code>…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, maxsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>], posLeft = <span class="keyword">new</span> <span class="keyword">int</span>[n], posRight = <span class="keyword">new</span> <span class="keyword">int</span>[n], ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum[i+<span class="number">1</span>] = sum[i]+nums[i];</span><br><span class="line">        <span class="comment">// DP for starting index of the left max sum interval</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k, tot = sum[k]-sum[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i+<span class="number">1</span>]-sum[i+<span class="number">1</span>-k] &gt; tot) &#123;</span><br><span class="line">                posLeft[i] = i+<span class="number">1</span>-k;</span><br><span class="line">                tot = sum[i+<span class="number">1</span>]-sum[i+<span class="number">1</span>-k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                posLeft[i] = posLeft[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DP for starting index of the right max sum interval</span></span><br><span class="line">       <span class="comment">// caution: the condition is "&gt;= tot" for right interval, and "&gt; tot" for left interval</span></span><br><span class="line">       <span class="comment">// This is to make sure that we always choose leftmost start idx</span></span><br><span class="line">        posRight[n-k] = n-k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-k-<span class="number">1</span>, tot = sum[n]-sum[n-k]; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i+k]-sum[i] &gt;= tot) &#123;</span><br><span class="line">                posRight[i] = i;</span><br><span class="line">                tot = sum[i+k]-sum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                posRight[i] = posRight[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test all possible middle interval</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n-<span class="number">2</span>*k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = posLeft[i-<span class="number">1</span>], r = posRight[i+k];</span><br><span class="line">            <span class="keyword">int</span> tot = (sum[i+k]-sum[i]) + (sum[l+k]-sum[l]) + (sum[r+k]-sum[r]);</span><br><span class="line">            <span class="keyword">if</span> (tot &gt; maxsum) &#123;</span><br><span class="line">                maxsum = tot;</span><br><span class="line">                ans[<span class="number">0</span>] = l; ans[<span class="number">1</span>] = i; ans[<span class="number">2</span>] = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 416 - Partition Equal Subset Sum</title>
      <link href="/11/05/2019/416/"/>
      <url>/11/05/2019/416/</url>
      
        <content type="html"><![CDATA[<p>This problem is pretty much alike the 518. Coin Change 2.<br>Difference are:</p><ul><li>We CANNOT reuse an element while it can be reused in LT518. </li><li>We have to preprocess the input. Then this question convert to:<br><code>Can we make a sum/2 using the element in arr or not?</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//I just figured out the differences between this problem and </span></span><br><span class="line">    <span class="comment">//518. Coin Change 2. In this problem, we CANNOT reuse an element while it can be reused in LT518. </span></span><br><span class="line">    <span class="comment">//That is why we have dp[i-1][j-nums[i-1]] in this problem and dp[i][j-coins[i-1]] in LT518</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="comment">//         boolean[][] dp = new boolean[n+1][sum+1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         dp[0][0] = true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; n+1; i++) &#123;</span></span><br><span class="line"><span class="comment">//             dp[i][0] = true;//不用任何数字，可以凑成0sum</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (int j = 1; j &lt; sum+1; j++) &#123;</span></span><br><span class="line"><span class="comment">//             dp[0][j] = false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             for (int j = 1; j &lt;= sum; j++) &#123;</span></span><br><span class="line"><span class="comment">//                 if (j &gt;= nums[i-1]) &#123;</span></span><br><span class="line">                       <span class="comment">//both i-1 so cur only depend on prev row</span></span><br><span class="line"><span class="comment">//                     dp[i][j] = (dp[i - 1][j] || dp[i - 1][j - nums[i-1]]);// dp[i - 1] because each ele can only be used once</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return dp[n][sum];</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Every loop of nums refreshes dp array. We might get dp[i] from dp[i-num] whose index is smaller than i. If we increase the index of sum from 0 to sum, we will get dp[i] from dp[i-num] , while dp[i-num] has been updated in this loop. This dp[i-num] is not the number we got from the previous loop.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// So why would we do this? This is because the numbers in nums can only be used once. If we can choose each number several times, we have to increase i from 0 to sum. Which means, if we are going to choose dp[i], we have to consider the situation where dp[i] has been chosen before. In this case, dp[i] is updated from dp[i-num] which is in the same loop with dp[i]. This dp[i-num] we use is a kind of result where dp[i] has been chosen.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//Arrays.fill(dp, false);</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sum; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                    dp[i] = dp[i] || dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 173 - Binary Search Tree Iterator</title>
      <link href="/11/05/2019/173/"/>
      <url>/11/05/2019/173/</url>
      
        <content type="html"><![CDATA[<p>This is just a iterative BST in-order traversal. Check LC94 out. You can search in my blog.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//or O(n) time O(n) space preprocess</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(h) space</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//same as inorder traversal, amortized O(1) time, worst O(N) time</span></span><br><span class="line">    <span class="comment">//(you may assume that next() call will always be valid)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur =  stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty() || cur != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BST Iterator amortized in-order </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 94 - Binary Tree Inorder Traversal</title>
      <link href="/11/05/2019/94/"/>
      <url>/11/05/2019/94/</url>
      
        <content type="html"><![CDATA[<h2 id="Res-of-inorder-traversal-would-be-an-increasing-arr"><a href="#Res-of-inorder-traversal-would-be-an-increasing-arr" class="headerlink" title="Res of inorder traversal would be an increasing arr."></a>Res of inorder traversal would be an increasing arr.</h2><p>The iterative way of in-order traversal is different from that of pre and post order traversal.<br><code>So you have to remember the code</code> as it is very important and can be applied to multiple questions.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         helper(res, root);</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void helper(List&lt;Integer&gt; res, TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) return;</span></span><br><span class="line"><span class="comment">//         helper(res, root.left);</span></span><br><span class="line"><span class="comment">//         res.add(root.val);</span></span><br><span class="line"><span class="comment">//         helper(res, root.right);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Morris inorder tree traversal   time O(n) space O(1)</span></span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// TreeNode predecessor = null;</span></span><br><span class="line">        <span class="comment">// TreeNode cur = root;</span></span><br><span class="line">        <span class="comment">// while (cur != null)&#123;</span></span><br><span class="line">        <span class="comment">//     if (cur.left != null)&#123; //root.left exist</span></span><br><span class="line">        <span class="comment">//         //find predecessor(right most node in first left node)</span></span><br><span class="line">        <span class="comment">//         predecessor = cur.left;</span></span><br><span class="line">        <span class="comment">//         while (predecessor.right != null &amp;&amp; predecessor.right != cur) &#123;</span></span><br><span class="line">        <span class="comment">//             predecessor = predecessor.right;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         //predecessor.right exists(we wire it for tracking back purpose before)</span></span><br><span class="line">        <span class="comment">//         if (predecessor.right != null)&#123;</span></span><br><span class="line">        <span class="comment">//             predecessor.right = null;</span></span><br><span class="line">        <span class="comment">//             res.add(cur.val);</span></span><br><span class="line">        <span class="comment">//             cur = cur.right;</span></span><br><span class="line">        <span class="comment">//         &#125; else &#123;//predecessor.right not exists</span></span><br><span class="line">        <span class="comment">//             predecessor.right = cur;//(wire it for tracking back)</span></span><br><span class="line">        <span class="comment">//             cur = cur.left;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;//root.left not exist</span></span><br><span class="line">        <span class="comment">//         res.add(cur.val);</span></span><br><span class="line">        <span class="comment">//         cur = cur.right;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode in-order recursive iterative morris-traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 75 - Sort Colors</title>
      <link href="/11/05/2019/75/"/>
      <url>/11/05/2019/75/</url>
      
        <content type="html"><![CDATA[<p>Similar question: 283 - Move Zeroes</p><p>notice here we have to maintain the relative order of the non-zero elements.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2 different one pass constant space solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//swap O(1) space</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, r);</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, i, b);</span><br><span class="line">                i--;<span class="comment">//because this might be 0, so we have to check again</span></span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//non-swap O(1) space</span></span><br><span class="line">        <span class="comment">// int n0 = -1, n1 = -1, n2 = -1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (nums[i] == 0) &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//         nums[++n1] = 1;</span></span><br><span class="line">        <span class="comment">//         nums[++n0] = 0;</span></span><br><span class="line">        <span class="comment">//     &#125; else if (nums[i] == 1) &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//         nums[++n1] = 1;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 283 - Move Zeroes</title>
      <link href="/11/05/2019/283/"/>
      <url>/11/05/2019/283/</url>
      
        <content type="html"><![CDATA[<p>Similar question: 75. Sort Colors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//if(i != start)&#123;</span></span><br><span class="line">                    exchange(nums, i, start);</span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 93 - Restore IP Addresses</title>
      <link href="/11/05/2019/93/"/>
      <url>/11/05/2019/93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs  3*3*3 = 27 time complexity?</span></span><br><span class="line">    <span class="comment">//If one already put a dot that leaves only 3 possibilities for the next dot to be placed : after one digit, after two digits, or after three digits. The first dot has only 3 available slots as well.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        doRestore(result, <span class="string">""</span>, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRestore</span><span class="params">(List&lt;String&gt; result, String path, String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() &amp;&amp; k == <span class="number">4</span>) &#123;</span><br><span class="line">            result.add(path.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || k == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">3</span>) &amp;&amp; i &lt;= s.length(); i++) &#123; <span class="comment">// Avoid leading 0</span></span><br><span class="line">            String part = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (Integer.valueOf(part) &lt;= <span class="number">255</span>)</span><br><span class="line">                doRestore(result, path + <span class="string">"."</span> + part, s.substring(i), k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 287 - Find the Duplicate Number</title>
      <link href="/11/05/2019/287/"/>
      <url>/11/05/2019/287/</url>
      
        <content type="html"><![CDATA[<p>Similar question: Linked List Cycle II<br><img src="https://leetcode.com/problems/linked-list-cycle-ii/Figures/142/diagram.png" alt="287"><br>Basically, you will have to have 2 pointers, fast and slow, and fast run 2 step each time, slow run 1 step each time, 2 pointers stop at the first intersection. Keep moving the slow form this intersection and have a new pointer start form the start point also with 1 step, the second interscetion will be the duplicate one. </p><p>//和442的区别是：1.只能有一个重复的数字。2.不能modify array</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//         Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         for (int num : nums) &#123;</span></span><br><span class="line"><span class="comment">//             if (seen.contains(num)) &#123;</span></span><br><span class="line"><span class="comment">//                 return num;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             seen.add(num);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return -1;</span></span><br><span class="line">        <span class="keyword">int</span> hare = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tortoise = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        tortoise = nums[tortoise];<span class="comment">//because there is no 0 in nums, so nums[0] can't be a part of the traversal.</span></span><br><span class="line">        hare = nums[nums[hare]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (hare != tortoise) &#123;</span><br><span class="line">            tortoise = nums[tortoise];</span><br><span class="line">            hare = nums[nums[hare]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> intersection = tortoise;</span><br><span class="line">        <span class="keyword">int</span> start = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (intersection != start) &#123;</span><br><span class="line">            intersection = nums[intersection];</span><br><span class="line">            start = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 442 - Find All Duplicates in an Array</title>
      <link href="/11/05/2019/442/"/>
      <url>/11/05/2019/442/</url>
      
        <content type="html"><![CDATA[<p>The key is there always a corresponding index exist in the arr. So we can make use of this attribute to solve this question in O(1) space.</p><p>//和287的区别：多个重复数字，并且可以modify nums来做标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n), space O(n), use hashset</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time O(n) space O(1), notice here 1&lt;=a[i]&lt;=n</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>) &#123;<span class="comment">//negative means we meet this before</span></span><br><span class="line">               res.add(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//mark as visited</span></span><br><span class="line">               nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 56 - Merge Intervals</title>
      <link href="/11/04/2019/56/"/>
      <url>/11/04/2019/56/</url>
      
        <content type="html"><![CDATA[<p>Sort the intervals according to the start time of each interval.<br>Keep a list to track the res.<br><code>if (list.isEmpty() || list.peekLast()[1] &lt; interval[0])</code> there is no interval.<br>if there is a overlap, change the end time of the last element in the list.<br><code>list.getLast()[1] = Math.max(list.peekLast()[1], interval[1]);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class Solution &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Time complexity: O(nlogn)</span></span><br><span class="line">    <span class="comment">//Space complexity: O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length &lt; <span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</span></span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//Deque&lt;int[]&gt; list = new ArrayDeque&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.isEmpty() || list.peekLast()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                list.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//overlap</span></span><br><span class="line">                list.getLast()[<span class="number">1</span>] = Math.max(list.peekLast()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[][] res = new int[list.size()][2];</span></span><br><span class="line">        <span class="comment">// int index = 0;</span></span><br><span class="line">        <span class="comment">// for(int[] interval: list) &#123;</span></span><br><span class="line">        <span class="comment">//     res[index++] = interval;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Interval List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1055 - Shortest Way to Form String</title>
      <link href="/11/04/2019/1055/"/>
      <url>/11/04/2019/1055/</url>
      
        <content type="html"><![CDATA[<p>Whether target can be formed by source’s subsequence.<br>t: “xzyxz”<br>s: “xyz”<br>return 3 because <code>t = &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先问能不能，简化成一个判断t里面的char是否都在s中，用一个hashset把s中的字母存一下，iterate 一下t就好</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(M * N)  space O(1) (brute force)</span></span><br><span class="line">        <span class="comment">// char[] sArr = source.toCharArray(), tArr = target.toCharArray();</span></span><br><span class="line">        <span class="comment">// int res = 0;</span></span><br><span class="line">        <span class="comment">// int i = 0;</span></span><br><span class="line">        <span class="comment">// while (i &lt; tArr.length) &#123;</span></span><br><span class="line">        <span class="comment">//     int temp = i;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; sArr.length; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (i &lt; tArr.length &amp;&amp; sArr[j] == tArr[i])</span></span><br><span class="line">        <span class="comment">//             i++;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     if (i == temp) return -1;</span></span><br><span class="line">        <span class="comment">//     res++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(NlogM)</span></span><br><span class="line">        <span class="keyword">char</span>[] sArr = source.toCharArray(), tArr = target.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt;[] idx = <span class="keyword">new</span> List[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) idx[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sArr.length; i++) idx[sArr[i] - <span class="string">'a'</span>].add(i);</span><br><span class="line">        <span class="keyword">int</span> jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ii &lt; tArr.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; curList = idx[tArr[ii] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (curList.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = binarySearch(curList,jj); <span class="comment">//get insert position</span></span><br><span class="line">            <span class="keyword">if</span> (k == curList.size()) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                jj = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jj = curList.get(k) + <span class="number">1</span>;</span><br><span class="line">                ii++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr.get(mid) == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.get(mid) &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//time O(N) , and build the map cost 26 * M</span></span><br><span class="line">    <span class="comment">//     char[] cs = source.toCharArray(), ts = target.toCharArray();</span></span><br><span class="line">    <span class="comment">//     int[][] idx = new int[26][cs.length];</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; cs.length; i++) idx[cs[i] - 'a'][i] = i + 1;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         for (int j = cs.length - 1, pre = 0; j &gt;= 0; j--) &#123;</span></span><br><span class="line">    <span class="comment">//             if (idx[i][j] == 0) idx[i][j] = pre;</span></span><br><span class="line">    <span class="comment">//             else pre = idx[i][j];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     int res = 1, j = 0;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ts.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (j == cs.length) &#123;</span></span><br><span class="line">    <span class="comment">//             j = 0;</span></span><br><span class="line">    <span class="comment">//             res++;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if (idx[ts[i] - 'a'][0] == 0) return -1;</span></span><br><span class="line">    <span class="comment">//         j = idx[ts[i] - 'a'][j];</span></span><br><span class="line">    <span class="comment">//         if (j == 0 ) &#123;</span></span><br><span class="line">    <span class="comment">//             res++;</span></span><br><span class="line">    <span class="comment">//             i--;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode binarySearch DP Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 986 - Interval List Intersections</title>
      <link href="/11/04/2019/986/"/>
      <url>/11/04/2019/986/</url>
      
        <content type="html"><![CDATA[<p>After getting lo and hi, you need to advance the pointer.<br>Compare the end, and the one with smaller end with be discarded because it can’t contribute to the next intersection anymore.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = Math.max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> hi = Math.min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;lo, hi&#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]) &#123;<span class="comment">//the one with smaller end should be discarded</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode 2-pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 5 - Longest Palindromic Substring</title>
      <link href="/11/03/2019/5/"/>
      <url>/11/03/2019/5/</url>
      
        <content type="html"><![CDATA[<p>For better understanding of this problem, I strongly recommend <code>using both the DP and 2-pointer</code> solution.<br>And once you can solve this problem using DP, you can also solve <code>lc516</code> and <code>lc1143</code> which are all very similar questions.(<code>search in my blog</code>)<br>And I strongly recommend take a look at those 2 questions for better understanding of this kind of “longest XXX Substring/Subsequence” problem.</p><p>//516 1216 1143 those questions are also pretty alike this one.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lo, maxLen;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time n^2 space n^2</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n - <span class="number">1</span>; j++) &#123; <span class="comment">//expand, not contract</span></span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; (j - i + <span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    lo = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(lo, lo + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time n^2 space O(1)</span></span><br><span class="line"><span class="comment">//         int len = s.length();</span></span><br><span class="line"><span class="comment">//     if (len &lt; 2)</span></span><br><span class="line"><span class="comment">// return s;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//             extend(s, i, i + 1);//even</span></span><br><span class="line"><span class="comment">//             extend(s, i, i);//odd</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return s.substring(lo, lo + maxLen);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void extend (String s, int j, int k) &#123;</span></span><br><span class="line"><span class="comment">//         while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span></span><br><span class="line"><span class="comment">//             j--;</span></span><br><span class="line"><span class="comment">//             k++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         //after valid one, the j and k will be one more than it should be, so we use k-j-1 rather than k-j+1</span></span><br><span class="line"><span class="comment">//         if (maxLen &lt; k - j - 1) &#123;</span></span><br><span class="line"><span class="comment">//             lo = j + 1;</span></span><br><span class="line"><span class="comment">//        maxLen = k - j - 1;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode dp Dynamic Programing 2-pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 518 - Coin Change 2</title>
      <link href="/11/02/2019/518/"/>
      <url>/11/02/2019/518/</url>
      
        <content type="html"><![CDATA[<p>Use DP to solve this problem and use rolling arr to optimize the space in to O(amount).<br>Similar question: LC416.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time amount * n, space amount * n</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[coins.length+1][amount+1];</span></span><br><span class="line">        <span class="comment">//这里是指amount是0的话总至少有一种方法就是不用任何硬币？</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// //i means how many coins </span></span><br><span class="line">        <span class="comment">// dp[0][j] = 0, so don't have to initialize</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= coins.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">//     for (int j = 1; j &lt;= amount; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         dp[i - 1][j]不用这个硬币，到这个amount dp[i][j - coins[i - 1]]用这个硬币，到这个amount</span></span><br><span class="line">        <span class="comment">//         dp[i][j] = dp[i - 1][j] + (j &gt;= coins[i - 1] ? dp[i][j - coins[i - 1]]: 0); //i-1 prev row, i cur row</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[coins.length][amount];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time amount * n, space amount</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 322 - Coin Change</title>
      <link href="/11/02/2019/322/"/>
      <url>/11/02/2019/322/</url>
      
        <content type="html"><![CDATA[<p>The difference between this question and the one can be solved with greedy is that this in this question, the denominations of the coins are decided by the input arr.<br>If you are given an arr of denomination with <code>1</code> in it,<br>you can just use greedy to solve the problem in <code>linear time</code>.</p><p>ex: coins = [1,2,5] amount = 11<br> 5 + 5 + 1</p><p>but if the input has no 1 in it, you will have to use DP<br>and the time complexity will be <code>O(n * amount)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n * amount) space O(amount)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//no way to make 0 amount</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">//don't use cur or use cur</span></span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ?  -<span class="number">1</span> : dp[amount];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里之所以使用dp是因为面额是自定义的。如果使用贪心算法，有可能出现硬币凑不整的情况。比如 5，6 凑10， 贪心算法会凑不整。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 449 - Serialize and Deserialize BST</title>
      <link href="/11/02/2019/449/"/>
      <url>/11/02/2019/449/</url>
      
        <content type="html"><![CDATA[<p>use max-min boundary to deserialize<br>2 ways to deserialize:</p><ul><li>use queue</li><li>use reference type (such as array) as idx and pass it to parameter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">//normal way</span></span><br><span class="line">    <span class="comment">// private static final String SPLITER = ",";</span></span><br><span class="line">    <span class="comment">// private static final String NULL = "N";</span></span><br><span class="line">    <span class="comment">// // Encodes a tree to a single string.</span></span><br><span class="line">    <span class="comment">// public String serialize(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     StringBuilder st = new StringBuilder();</span></span><br><span class="line">    <span class="comment">//     serialize(root, st);</span></span><br><span class="line">    <span class="comment">//     return st.toString();</span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">    <span class="comment">// public void serialize(TreeNode root, StringBuilder st) &#123;</span></span><br><span class="line">    <span class="comment">//     if (root == null) st.append(NULL + SPLITER);</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         st.append(root.val + SPLITER);</span></span><br><span class="line">    <span class="comment">//         serialize(root.left, st);</span></span><br><span class="line">    <span class="comment">//         serialize(root.right, st);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// // Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="comment">// public TreeNode deserialize(String data) &#123;</span></span><br><span class="line">    <span class="comment">//     Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     queue.addAll(Arrays.asList(data.split(SPLITER)));</span></span><br><span class="line">    <span class="comment">//     return deseralize(queue);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public TreeNode deseralize(Queue&lt;String&gt; queue) &#123;</span></span><br><span class="line">    <span class="comment">//     String cur = queue.poll();</span></span><br><span class="line">    <span class="comment">//     if (cur.equals(NULL)) return null;</span></span><br><span class="line">    <span class="comment">//     TreeNode root = new TreeNode(Integer.parseInt(cur));</span></span><br><span class="line">    <span class="comment">//     root.left = deseralize(queue);</span></span><br><span class="line">    <span class="comment">//     root.right = deseralize(queue);</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">     <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preorder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sb.append((<span class="keyword">char</span>)root.val);</span><br><span class="line">        preorder(root.left, sb);</span><br><span class="line">        preorder(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = data.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> constructTree(chs, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//idx 是引用类型？ 用单个数字变量替换不可以   (Do not use class member/global/static variables to store states)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span>[] idx, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx[<span class="number">0</span>]==chs.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>)chs[idx[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(value &lt; low || value &gt; high) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        idx[<span class="number">0</span>]++;</span><br><span class="line">        root.left = constructTree(chs, idx, low, value);</span><br><span class="line">        root.right = constructTree(chs, idx, value, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 297 - Serialize and Deserialize Binary Tree</title>
      <link href="/11/01/2019/297/"/>
      <url>/11/01/2019/297/</url>
      
        <content type="html"><![CDATA[<p>Good question with many variations that each could be ask as a follow up when an interview.</p><h2 id="These-are-the-3-most-frequent-asked-follow-ups"><a href="#These-are-the-3-most-frequent-asked-follow-ups" class="headerlink" title="These are the 3 most frequent asked follow ups."></a>These are the 3 most frequent asked follow ups.</h2><p><code>N-array-tree/BST/encoded string should be as compact as possible</code></p><p>for normal question, you can add null and spliter into the preorder traversal. </p><p>for <code>N-array-tree</code>, you can store the val and it’s children’s size as a pair into the stack. (code implementation down below)</p><p>for <code>BST</code>, you can use the max-min boundary checkout my blog here <a href="https://haichao.us/11/02/2019/449/" target="_blank" rel="noopener">449</a></p><p>for <code>encoded string should be as compact as possible</code> you can think one node as a signle char character, (in java, UTF16 been used), so you can use a char array to store the res, no spliter needed. code implementation here for BST <a href="https://haichao.us/11/02/2019/449/" target="_blank" rel="noopener">449</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLITER = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NULL = <span class="string">"N"</span>;</span><br><span class="line">    / / Encodes a tree to a single string.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, st);</span><br><span class="line">        <span class="keyword">return</span> st.toString();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder st)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) st.append(NULL + SPLITER);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st.append(root.val + SPLITER);</span><br><span class="line">            serialize(root.left, st);</span><br><span class="line">            serialize(root.right, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                 <span class="comment">// Collection.toArray()</span></span><br><span class="line">        queue.addAll(Arrays.asList(data.split(SPLITER)));</span><br><span class="line">        <span class="keyword">return</span> deseralize(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deseralize</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        root.left = deseralize(queue);</span><br><span class="line">        root.right = deseralize(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感谢 zz 提供代码. 她非让我把她的linkedin放在这儿。。想看就看一下无所谓了</span></span><br><span class="line"><span class="comment">// https://www.linkedin.com/in/zhao-ma-05b828155/</span></span><br><span class="line"><span class="comment">//     针对N-ary树，要注意的问题有：</span></span><br><span class="line"><span class="comment">// 1.序列化时：放入stack时节点的顺序</span></span><br><span class="line"><span class="comment">// 2.分序列化时：如何确定子节点的数量</span></span><br><span class="line"><span class="comment">// 3.是否需要特殊标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution:</span></span><br><span class="line"><span class="comment">// 1.因为stack是FILO，所以先取出children序列，然后逆序加入stack中</span></span><br><span class="line"><span class="comment">// 2.在序列化阶段同时记录子节点数目，跟在root值之后</span></span><br><span class="line"><span class="comment">// 3.不需要。因为size可以控制循环轮数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment">//     public String serialize(Node root) &#123;</span></span><br><span class="line"><span class="comment">//         if(root == null) return "";</span></span><br><span class="line"><span class="comment">//         StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         stack.push(root);</span></span><br><span class="line"><span class="comment">//         while(!stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             Node cur = stack.pop();</span></span><br><span class="line"><span class="comment">//             int size = cur.children.size();</span></span><br><span class="line"><span class="comment">//             sb.append(cur.val).append(",");</span></span><br><span class="line"><span class="comment">//             sb.append(size).append(",");</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//             //FILO</span></span><br><span class="line"><span class="comment">//             List&lt;Node&gt; children = cur.children;</span></span><br><span class="line"><span class="comment">//             for(int i = size - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//                 stack.push(children.get(i));</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return sb.toString();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment">//     public Node deserialize(String data) &#123;</span></span><br><span class="line"><span class="comment">//         if(data.length() == 0) return null;</span></span><br><span class="line"><span class="comment">//         String[] arr = data.split(",");</span></span><br><span class="line"><span class="comment">//         Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         for(String s: arr) &#123;</span></span><br><span class="line"><span class="comment">//             queue.offer(s);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return helper(queue);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     public Node helper(Queue&lt;String&gt; queue) &#123;</span></span><br><span class="line"><span class="comment">//         if(queue.isEmpty()) return null;</span></span><br><span class="line"><span class="comment">//         int cur = Integer.valueOf(queue.poll());</span></span><br><span class="line"><span class="comment">//         int size = Integer.valueOf(queue.poll());</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Node root = new Node(cur, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//         while(size-- &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//             root.children.add(helper(queue));</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return root;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 236 - Lowest Common Ancestor of a Binary Tree</title>
      <link href="/11/01/2019/236/"/>
      <url>/11/01/2019/236/</url>
      
        <content type="html"><![CDATA[<p>FB recent interview question.</p><h3 id="2-ways-to-solve-this-problem"><a href="#2-ways-to-solve-this-problem" class="headerlink" title="2 ways to solve this problem."></a>2 ways to solve this problem.</h3><p><code>Iterative and recursive</code>. The recursive one is a little bit hard to understand but easier to modify when change to N-array tree. (<code>code for N-array tree will be append at last</code>)</p><p>Beside normal O(N) implementation, Tarjan and Doubling Algorithm can achieve O(logN) time complexity. But interviewer don’t expect you answer with that within a 45 min interview. So these 2 algorithms are just for displaying purpose. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time space for Both solutions are O(n)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//         Share my understanding of what lowestCommonAncestor() does:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if both p and q exist in Tree rooted at root, then return their LCA</span></span><br><span class="line">        <span class="comment">// if neither p and q exist in Tree rooted at root, then return null</span></span><br><span class="line">        <span class="comment">// if only one of p or q (NOT both of them), exists in Tree rooted at root, return it</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (root == null || p == root || q == root) return root;</span></span><br><span class="line">        <span class="comment">// TreeNode left = lowestCommonAncestor(root.left, p, q);</span></span><br><span class="line">        <span class="comment">// TreeNode right = lowestCommonAncestor(root.right, p, q);</span></span><br><span class="line">        <span class="comment">// if (left == null) &#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125; else if (right == null) &#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     //right != null &amp;&amp; left != null</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line">        <span class="comment">// &#125;  </span></span><br><span class="line">        </span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        parent.put(root, <span class="keyword">null</span>);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(parent.containsKey(p) &amp;&amp; parent.containsKey(q))) &#123;<span class="comment">//or !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">// right left or left right really doesn't matter</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.right, node);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.left, node);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ancestors.contains(q))</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Time complexity: O(n)</span></span><br><span class="line"><span class="comment">//Space complexity: O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public static TreeNode helper(TreeNode root, TreeNode p, TreeNode q) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return null;</span></span><br><span class="line">    <span class="comment">//     if(root.val == p.val || root.val == q.val) return root;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int count = 0;</span></span><br><span class="line">    <span class="comment">//     TreeNode last = null;</span></span><br><span class="line">    <span class="comment">//     for(TreeNode child: root.children) &#123;</span></span><br><span class="line">    <span class="comment">//         if(count &gt; 1) break; //root can be determined as LCA</span></span><br><span class="line">    <span class="comment">//         TreeNode ans = helper(child, p, q);</span></span><br><span class="line">    <span class="comment">//         if(ans != null) &#123; //can find p/q from current child</span></span><br><span class="line">    <span class="comment">//             count++;</span></span><br><span class="line">    <span class="comment">//             last = ans;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //count means the number of child nodes to help find p/q </span></span><br><span class="line">    <span class="comment">//     if(count == 0) return null; //cannot find p/q</span></span><br><span class="line">    <span class="comment">//     if(count == 1) return last; //find p/q only from one child</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 76 - Minimum Window Substring</title>
      <link href="/11/01/2019/76/"/>
      <url>/11/01/2019/76/</url>
      
        <content type="html"><![CDATA[<p>Recent facebook question.<br>classic sliding window problem.<br>first you need a counter to track the match count.<br>Extend the window to a valid answer, then contract the window until it’s not a valid window. Extend again…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n) space O(n) n= s.len + t.len</span></span><br><span class="line">    <span class="comment">//one little improvement: when length of string TT is way too small </span></span><br><span class="line">    <span class="comment">//than the length of string SS and </span></span><br><span class="line">    <span class="comment">//string SS consists of numerous characters which are not present in TT.</span></span><br><span class="line">    <span class="comment">//S = "ABCDDDDDDEEAFFBC" T = "ABC"</span></span><br><span class="line">  <span class="comment">//filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]</span></span><br><span class="line">  <span class="comment">//Here (0, 'A') means in string S character A is at index 0.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> dicCount = map.getOrDefault(c, <span class="number">0</span>);</span><br><span class="line">            map.put(c, dicCount + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> matchCount = <span class="number">0</span>, startIndex = <span class="number">0</span>, slow = <span class="number">0</span>, minLen = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; s.length(); fast++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(fast);</span><br><span class="line">            Integer count = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//get a match</span></span><br><span class="line">            map.put(ch, count - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//1 -&gt; 0</span></span><br><span class="line">                matchCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (matchCount == map.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = fast - slow + <span class="number">1</span>;</span><br><span class="line">                    startIndex = slow;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// contract the window until matchCount != map.size()</span></span><br><span class="line">                <span class="keyword">char</span> leftMostChar = s.charAt(slow++);</span><br><span class="line">                Integer leftCount = map.get(leftMostChar);</span><br><span class="line">                <span class="keyword">if</span> (leftCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//get a math</span></span><br><span class="line">                map.put(leftMostChar, leftCount + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (leftCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//0 -&gt; 1</span></span><br><span class="line">                    matchCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(startIndex, startIndex + minLen);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode sliding window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 37 - Sudoku Solver</title>
      <link href="/11/01/2019/37/"/>
      <url>/11/01/2019/37/</url>
      
        <content type="html"><![CDATA[<p>This is a pretty classic backtracking problem.<br>Two ponints we need to notice:</p><ul><li><p>validcheck: <code>board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3]</code> can normalize a node to it’s block’s upleft corner.</p></li><li><p>the solve function return boolean</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//brute force 9^81   backtracking: 9*8*7....*1 for one row, not more than (9!)^9</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// backtracking</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isValid(board, i, j, c)) &#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span> (solve(board)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//no way to fill the blank, dead end </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// all the blanks are filled </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col]  == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 743 - Pacific Atlantic Water Flow</title>
      <link href="/11/01/2019/417/"/>
      <url>/11/01/2019/417/</url>
      
        <content type="html"><![CDATA[<p>This is a dfs problem.<br>You can construct 2 visited matrix for Pacific and Atlantic.<br>After 2 dfs, you will find the boundary by finding the intersection of these 2 matrix.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">//time O(m*n)</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[][] pacific = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            dfs(matrix, pacific, i, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//the old height will be 0 initially</span></span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            dfs(matrix, atlantic, i, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//top</span></span><br><span class="line">            dfs(matrix, pacific, <span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//bottom</span></span><br><span class="line">            dfs(matrix, atlantic, m - <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(i, j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || matrix[i][j] &lt; height) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(matrix, visited, i + <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i, j + <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i - <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i, j - <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 863 - All Nodes Distance K in Binary Tree</title>
      <link href="/10/30/2019/863/"/>
      <url>/10/30/2019/863/</url>
      
        <content type="html"><![CDATA[<p>Frequent ask question on Amazon interviews.</p><p>We need to find nodes that k nodes from the target.<br>So we have to do it using BFS.</p><ul><li>First, construct a map to store the parent-child relation. Because we need to go up when BFS.</li><li>Second, we need a visited set because we don’t want to revisit the same node twice.(this will happen when BFS meet the root node) </li></ul><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="863"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n) space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key: node, value: parent</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; vis = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(cur.left, cur);</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(cur.right, cur);</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q.clear();</span><br><span class="line">        q.add(target);</span><br><span class="line">        vis.add(target);<span class="comment">//once we go we can't go back, ex: 5 -&gt; 3(root), 3 -&gt; left, right. </span></span><br><span class="line">        <span class="keyword">while</span>(K-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span> &amp;&amp; vis.add(cur.left)) q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span> &amp;&amp; vis.add(cur.right)) q.add(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (map.get(cur) != <span class="keyword">null</span> &amp;&amp; vis.add(map.get(cur))) q.add(map.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) res.add(q.poll().val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 743 - Network Delay Time</title>
      <link href="/10/30/2019/743/"/>
      <url>/10/30/2019/743/</url>
      
        <content type="html"><![CDATA[<p>This is a pretty hard question, but also a frequent ask question in recent google interviews.<br>The best source on the internet is this one <a href="https://www.youtube.com/watch?v=vwLYDeghs_c" target="_blank" rel="noopener">Huahua</a></p><p>Bellman Ford and Dijkstra’s Algorithm can solve this problem, but the second one has better time complexity.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bellman Ford     </span></span><br><span class="line">    <span class="comment">//Complexity is O(VE), but the problem said N will be no more than 100, so the complexity should be O(E)</span></span><br><span class="line">    <span class="comment">//E = len(times), V = N in this problem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dijkstra's Algorithm  time:ElogE, space:O(N+E), the size of the graph O(E), plus the size of the other objects used O(N).</span></span><br><span class="line">    <span class="comment">//one source, mutilple destinations, shortest pass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time : times) graph.get(time[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">        <span class="comment">// PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;()&#123;</span></span><br><span class="line">        <span class="comment">//     public int compare(int[] a, int[] b) &#123;</span></span><br><span class="line">        <span class="comment">//         return a[1] - b[1];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;K, <span class="number">0</span>&#125;); <span class="comment">//0: dis from source</span></span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">if</span>(!visited.add(curr[<span class="number">0</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            dist = curr[<span class="number">1</span>];<span class="comment">//the last one is always the biggest one.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : graph.get(curr[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(neighbor[<span class="number">0</span>])) pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;neighbor[<span class="number">0</span>], neighbor[<span class="number">1</span>] + curr[<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.size() == N ? dist : -<span class="number">1</span>;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dijkstra Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Manual</title>
      <link href="/10/30/2019/hello-world/"/>
      <url>/10/30/2019/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Most of the posts are about leetcode.<br>I’ve done more than 500+ lc question and you can search any question you want.<br>Solutions that I posted are the best I can find online.<br>Feel free to email me if you have any question about my post. Happy coding!</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>Katherine Ma：</p><blockquote><ul><li>all to reply (multiple times)</li><li>the screen is broken when I moved in</li><li>Used to work on Leetcode when I wrote this solution, before 2019/02.<br><a href="https://leetcode.com/problems/divide-two-integers/discuss/142849/C%2B%2BJavaPython-Should-Not-Use-%22long%22-Int" target="_blank" rel="noopener">ref</a></li><li>I’ve never been a place that I went 3 days ago.</li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
