<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>leetcode 901 - Online Stock Span</title>
      <link href="/11/10/2019/901/"/>
      <url>/11/10/2019/901/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockSpanner</span> </span>&#123;</span><br><span class="line">    <span class="comment">//O(n) time, O(n) space</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;<span class="keyword">int</span>[]&gt; stack;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StockSpanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//amortized O(1) each time, O(n) time total(n is the number of calls to next())</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> price)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek()[<span class="number">0</span>] &lt;= price) &#123;</span><br><span class="line">          res += stack.pop()[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      stack.push(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;price, res&#125;);<span class="comment">//the stack here is descending (price)</span></span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your StockSpanner object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * StockSpanner obj = new StockSpanner();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next(price);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 34 - Find First and Last Position of Element in Sorted Array</title>
      <link href="/11/10/2019/34/"/>
      <url>/11/10/2019/34/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> a = findInsertPostion(nums, target);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// find where to insert target + 1, then index - 1 to find the last postion of target</span></span><br><span class="line">            <span class="comment">//[1], 1 case, return [0, 0]</span></span><br><span class="line">        <span class="keyword">if</span> (a &lt; <span class="number">0</span> || a &gt;= nums.length || nums[a] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> b = findInsertPostion(nums, target + <span class="number">1</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;a, b - <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//check question #35 out!// 35不带重复，此题带重复。所以如果这种写法不能保证logN复杂度</span></span><br><span class="line">    <span class="comment">// public int findInsertPostion(int[] nums, int target) &#123;</span></span><br><span class="line">    <span class="comment">//     int lo = 0, hi = nums.length - 1;</span></span><br><span class="line">    <span class="comment">//     while (lo &lt;= hi) &#123;</span></span><br><span class="line">    <span class="comment">//         int mid = lo + (hi - lo) / 2;</span></span><br><span class="line">    <span class="comment">//         if (nums[mid] &gt; target) &#123;</span></span><br><span class="line">    <span class="comment">//             hi = mid - 1;</span></span><br><span class="line">    <span class="comment">//         &#125; else if (nums[mid] &lt; target) &#123;</span></span><br><span class="line">    <span class="comment">//             lo = mid + 1;</span></span><br><span class="line">    <span class="comment">//         &#125; else &#123;</span></span><br><span class="line">    <span class="comment">//             while (mid &gt; 0 &amp;&amp; nums[mid - 1] == nums[mid]) &#123;</span></span><br><span class="line">    <span class="comment">//                 mid--;</span></span><br><span class="line">    <span class="comment">//             &#125;</span></span><br><span class="line">    <span class="comment">//             return mid;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return lo;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这种情况可以handle带duplicate的情况，注意cornercase不一样</span></span><br><span class="line">    <span class="comment">//this one can handle duplicates in arr, this one return left most pos if duplicates exist.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findInsertPostion</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//wocao? 为啥要hi = n才能过[1], target 1 case, return [0, 0]</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//nums[mid] &gt;= target</span></span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Search Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 240 - Search a 2D Matrix II</title>
      <link href="/11/10/2019/240/"/>
      <url>/11/10/2019/240/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time complexity O(n + m)</span></span><br><span class="line">    <span class="keyword">if</span>(matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; i &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//follow up: find target (with or without duplicate, use binary search(重复的话就问target一共有多少个))</span></span><br><span class="line"><span class="comment">// if duplicateas are allowed, how many target are there in the matrix?</span></span><br><span class="line"><span class="comment">//use this binary search (check detail in lc 34)</span></span><br><span class="line"><span class="comment">//这种情况可以handle带duplicate的情况，注意cornercase不一样</span></span><br><span class="line"><span class="comment">// public int findInsertPostion(int[] nums, int target) &#123;</span></span><br><span class="line"><span class="comment">//     //wocao? 为啥要hi = n才能过[1], target 1 case, return [0, 0]</span></span><br><span class="line"><span class="comment">//     int lo = 0, hi = nums.length;</span></span><br><span class="line"><span class="comment">//     while (lo &lt; hi) &#123;</span></span><br><span class="line"><span class="comment">//         int mid = lo + (hi - lo) / 2;</span></span><br><span class="line"><span class="comment">//         if (nums[mid] &lt; target) &#123;</span></span><br><span class="line"><span class="comment">//             lo = mid + 1;</span></span><br><span class="line"><span class="comment">//         &#125; else &#123;</span></span><br><span class="line"><span class="comment">//             //nums[mid] &gt;= target</span></span><br><span class="line"><span class="comment">//             hi = mid;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     return lo;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Binary-Search Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 739 - Daily Temperatures</title>
      <link href="/11/09/2019/739/"/>
      <url>/11/09/2019/739/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line"><span class="comment">//         Stack&lt;Integer&gt; st = new Stack();</span></span><br><span class="line"><span class="comment">//         int[] res = new int[T.length];</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; T.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             while (!st.isEmpty() &amp;&amp; T[i] &gt; T[st.peek()]) &#123;</span></span><br><span class="line"><span class="comment">//                 int index = st.pop();</span></span><br><span class="line"><span class="comment">//                 res[index] = i - index;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//             st.push(i);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Stack&lt;Integer&gt; st = <span class="keyword">new</span> Stack();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st.isEmpty() &amp;&amp; T[i] &gt;= T[st.peek()]) &#123;</span><br><span class="line">                st.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (st.isEmpty()) &#123;</span><br><span class="line">                res[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i] = st.peek() - i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            st.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public int[] dailyTemperatures(int[] T) &#123;</span></span><br><span class="line"><span class="comment">//         int[] stack = new int[T.length];</span></span><br><span class="line"><span class="comment">//         int top = -1;</span></span><br><span class="line"><span class="comment">//         int[] ret = new int[T.length];</span></span><br><span class="line"><span class="comment">//         for(int i = 0; i &lt; T.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             while(top &gt; -1 &amp;&amp; T[i] &gt; T[stack[top]]) &#123;</span></span><br><span class="line"><span class="comment">//                 int idx = stack[top--];</span></span><br><span class="line"><span class="comment">//                 ret[idx] = i - idx;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             stack[++top] = i;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return ret;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 503 - Next Greater Element II</title>
      <link href="/11/09/2019/503/"/>
      <url>/11/09/2019/503/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n * <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; nums[i % n] &gt;= s.peek()) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">                res[i % n] = -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[i % n] = s.peek();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(nums[i % n]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Arrays.fill(res, -1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; n * 2; i++) &#123;</span></span><br><span class="line"><span class="comment">//             int num = nums[i % n]; </span></span><br><span class="line"><span class="comment">//             while (!s.isEmpty() &amp;&amp; nums[s.peek()] &lt; num)</span></span><br><span class="line"><span class="comment">//                 res[s.pop()] = num;</span></span><br><span class="line"><span class="comment">//             //if (i &lt; n) s.push(i);</span></span><br><span class="line"><span class="comment">//             s.push(i % n);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 496 - Next Greater Element I</title>
      <link href="/11/09/2019/496/"/>
      <url>/11/09/2019/496/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElement(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">//time and space both O(m + n)</span></span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums1.length];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = nums2.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums2[i]) &#123;</span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.isEmpty()) &#123;</span><br><span class="line">                map.put(nums2[i], -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(nums2[i], s.peek());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            s.push(nums2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = map.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 91 - Decode Ways</title>
      <link href="/11/09/2019/91/"/>
      <url>/11/09/2019/91/</url>
      
        <content type="html"><![CDATA[<p>Similiar questions:</p><ul><li><ol start="62"><li>Unique Paths</li></ol></li><li><ol start="70"><li>Climbing Stairs</li></ol></li><li><ol start="509"><li>Fibonacci Number</li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n) space O(n)      would the input be 0?</span></span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span> || s == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//no string, so only one way -&gt; no solution</span></span><br><span class="line">        dp[<span class="number">1</span>] = s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> oneDigit = Integer.valueOf(s.substring(i - <span class="number">1</span>, i));</span><br><span class="line">            <span class="keyword">int</span> twoDigit = Integer.valueOf(s.substring(i - <span class="number">2</span>, i));</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">1</span> &lt;= oneDigit &amp;&amp; <span class="number">9</span> &gt;= oneDigit) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (<span class="number">10</span> &lt;= twoDigit &amp;&amp; <span class="number">26</span> &gt;= twoDigit) &#123;</span><br><span class="line">                dp[i] += dp[i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">        <span class="comment">//we can get to O(1) space</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if(s.charAt(0) == '0') return 0;</span></span><br><span class="line">        <span class="comment">// // prev1 represents dp[i-2]</span></span><br><span class="line">        <span class="comment">// int prev1 = 1;</span></span><br><span class="line">        <span class="comment">// // prev2 represents dp[i-1]</span></span><br><span class="line">        <span class="comment">// int prev2 = 1;</span></span><br><span class="line">        <span class="comment">// int res = prev2;</span></span><br><span class="line">        <span class="comment">// for(int i = 1; i &lt; s.length(); i++)&#123;</span></span><br><span class="line">        <span class="comment">//     res = 0;</span></span><br><span class="line">        <span class="comment">//     // if prev1 and prev2 are both 0, we can jump out of the loop earlier</span></span><br><span class="line">        <span class="comment">//     if(prev1==0 &amp;&amp; prev2==0) return 0;</span></span><br><span class="line">        <span class="comment">//     if(s.charAt(i) != '0') res += prev2;</span></span><br><span class="line">        <span class="comment">//     int num = Integer.valueOf(s.substring(i-1,i+1));</span></span><br><span class="line">        <span class="comment">//     if(num &gt;= 10 &amp;&amp; num &lt;= 26) res += prev1;</span></span><br><span class="line">        <span class="comment">//     prev1 = prev2;</span></span><br><span class="line">        <span class="comment">//     prev2 = res;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (s.length() == 0 || s == null) return 0;</span></span><br><span class="line">        <span class="comment">// int[] res = new int[s.length()];</span></span><br><span class="line">        <span class="comment">// Arrays.fill(res, - 2); // can be any negative number</span></span><br><span class="line">        <span class="comment">// return decode(s, 0, res);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//time O(n) space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span> <span class="params">(String s, <span class="keyword">int</span> start, <span class="keyword">int</span>[] res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= s.length()) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//complete one, return 1</span></span><br><span class="line">        <span class="keyword">if</span> (res[start] != -<span class="number">2</span>) <span class="keyword">return</span> res[start];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        String oneDigit = s.substring(start, start + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (isValid(oneDigit)) &#123;</span><br><span class="line">            count += decode(s, start + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (start + <span class="number">2</span> &lt;= s.length()) &#123;</span><br><span class="line">            String twoDigit = s.substring(start, start + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (isValid(twoDigit)) &#123;</span><br><span class="line">                count += decode(s, start + <span class="number">2</span>, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        res[start] = count;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.valueOf(s);</span><br><span class="line">        <span class="keyword">return</span> res &gt;= <span class="number">1</span> &amp;&amp; res &lt;= <span class="number">26</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> String DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 199 - Binary Tree Right Side View</title>
      <link href="/11/09/2019/199/"/>
      <url>/11/09/2019/199/</url>
      
        <content type="html"><![CDATA[<p>You can use recursive(DFS) or BFS to solve this problem.<br>You must master all 2 solutions to pass the interview. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time and space O(n)</span></span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         dfs(root, 0, ans);</span></span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     private void dfs(TreeNode root, int level, List&lt;Integer&gt; ans) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) &#123;</span></span><br><span class="line"><span class="comment">//             return;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         if (level == ans.size()) &#123;</span></span><br><span class="line"><span class="comment">//             ans.add(root.val);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         dfs(root.right, level + 1, ans);</span></span><br><span class="line"><span class="comment">//         dfs(root.left, level + 1, ans); //still have this because rsv may exist in left branches </span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//time and space O(n)</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// reverse level traversal</span></span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        </span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = queue.size();</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                TreeNode cur = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (size == temp - <span class="number">1</span>) result.add(cur.val);<span class="comment">// the first one(start from right)</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>) queue.offer(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>) queue.offer(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Tree DFS BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 456 - 132 Pattern</title>
      <link href="/11/08/2019/456/"/>
      <url>/11/08/2019/456/</url>
      
        <content type="html"><![CDATA[<p>Similar stack questions: 496 503 901 1019 739</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find132pattern</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt; <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// time n^2</span></span><br><span class="line">        <span class="comment">// int min_i = Integer.MAX_VALUE;</span></span><br><span class="line">        <span class="comment">// for (int j = 0; j &lt; nums.length - 1; j++) &#123;</span></span><br><span class="line">        <span class="comment">//     min_i = Math.min(min_i, nums[j]);</span></span><br><span class="line">        <span class="comment">//     for (int k = j + 1; k &lt; nums.length; k++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (nums[k] &lt; nums[j] &amp;&amp; min_i &lt; nums[k])</span></span><br><span class="line">        <span class="comment">//             return true;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return false;</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Time complexity: O(n)</span></span><br><span class="line">        <span class="comment">//Space complexity: O(n) //in worst case, nums is in ascending order</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        <span class="comment">//index: s1&lt;s3&lt;s2</span></span><br><span class="line">        <span class="keyword">int</span> s2 = Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//since the index of s2 should be the largest, so iterate from the end of the array</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt; s2) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) &#123;<span class="comment">// value: cur &gt; stack.peek()    index: cur &lt; stack.peek()</span></span><br><span class="line">                s2 = stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(nums[i]);<span class="comment">//the ele in stack is descending</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Stack Monotonic-Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 241 - Different Ways to Add Parentheses</title>
      <link href="/11/08/2019/241/"/>
      <url>/11/08/2019/241/</url>
      
        <content type="html"><![CDATA[<p>The dfs <code>return a list</code>.<br>We split the input s by a operator. And dfs with left part and right part, get 2 list res.<br>Those 2 lists will be all the possible res of left and right part.<br>Use 2 lists form a new return list.<br><code>Notice if there is no operator in the input str, you will have to return a list with single number in it</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    解题思路：</span></span><br><span class="line"><span class="comment">    使用 DFS 处理。</span></span><br><span class="line"><span class="comment">    1. 在当前层，我们遍历当前层的input string, e.g. x + y,(注意：x 和 y 可能还是复合表达式，不一定只是数字) 每遇到一个运算符后，我们就将 String 拆分成 x 和 y 然后传到下一层。（注意，当前层可能有很多个运算符，出于simplicity 我们的例子才是 x + y，有可能是 x + y * z）</span></span><br><span class="line"><span class="comment">    2. What do we expect from child nodes?</span></span><br><span class="line"><span class="comment">        孩子1 会把 x 这个复合表达式的各种可能位置加括号的运算结果封装到一个 List&lt;Integer&gt; 中返回回来；同理，孩子2 会把 y 这个复合表达式的各种可能位置加括号的运算结果封装到一个 List&lt;Integer&gt; 中返回回来</span></span><br><span class="line"><span class="comment">    3. What will we do at current node?</span></span><br><span class="line"><span class="comment">        因为我们是遇到 “+” 然后把 string 拆分成 x 和 y 的，并且孩子1返回了 x 表达式各种可能的运算结果，孩子2返回了 y 表示式各种可能的运算结果，我们需要组合相加各种 x 和 y的结果，因为当前层拆分的符号是 "+" 号。</span></span><br><span class="line"><span class="comment">    4. What will we return to the parent node？</span></span><br><span class="line"><span class="comment">        在当前层我们每组和相加一种 x 和 y 的结果，就存入 List&lt;Integer&gt; 中，最后返回的就是这个 List&lt;Integer&gt;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    e.g. </span></span><br><span class="line"><span class="comment">            2 - 1 -1 * 5</span></span><br><span class="line"><span class="comment">    / \         /   \   /      \</span></span><br><span class="line"><span class="comment">   2  1-1*5   2-1  1*5  2-1-1   5</span></span><br><span class="line"><span class="comment">    (-)          (-)         (*)    分割当前String的运算符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ------Time Complexity = O(n!)-------- 因为每往下一层会少一个运算符. </span></span><br><span class="line"><span class="comment">    假设第 1 层有 n 个运算符，那么第 1 层就有 2n 个分支；第 2 层有 n-1 个运算符，所以第 2 层有 2*(n-1)个分支</span></span><br><span class="line"><span class="comment">    最后一层的分支数量是 2n * 2(n-1) * ... * 2 = 2 * n! = O(n!)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    -------Space Complexity = O(n! + n)--------- // 第二个 n 是 recursion tree's height</span></span><br><span class="line"><span class="comment">    这题和 merge sort 很像。我们可以盯着第1层看，每个运算符符拆分成的两个表达式会从子节点 return 回来结果，但是我们需要在第一层保存这些结果然后扎到另一个分支。当从倒数第二个运算符 return 回来结果后，我们需要保存前面所有的结果，which is O(n!)，然后扎到最后一个运算符的分支，所以 Space = O(n!)</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    这个 recursion tree 的 depth 应该是 O(n)，因为每一层会减少一个运算符，而运算符的数量是不会超过input string 的长度的</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Assumption: </span></span><br><span class="line"><span class="comment">    1. No integer overflow</span></span><br><span class="line"><span class="comment">    2. No divisor</span></span><br><span class="line"><span class="comment">    3. If input is null or empty, return empty list</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// Time Complexity = O(n!) 因为每往下一层会少一个运算符. </span></span><br><span class="line"><span class="comment">// Space Complexity = O(n! + n) // 第二个 n 是 recursion tree's height</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res = findAllResults(input);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Find all possible results</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Integer&gt; <span class="title">findAllResults</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; curRes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isOperator(str.charAt(i))) &#123;</span><br><span class="line">                List&lt;Integer&gt; left = findAllResults(str.substring(<span class="number">0</span>, i));</span><br><span class="line">                List&lt;Integer&gt; right = findAllResults(str.substring(i + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> l: left) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> r: right) &#123;</span><br><span class="line">                        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">if</span> (str.charAt(i) == <span class="string">'+'</span>) &#123;</span><br><span class="line">                            res = l + r;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">'-'</span>) &#123;</span><br><span class="line">                            res = l - r;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            res = l * r;</span><br><span class="line">                        &#125;</span><br><span class="line">                        curRes.add(res);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// corner case: no operators, only number</span></span><br><span class="line">        <span class="keyword">if</span> (curRes.size() == <span class="number">0</span>) &#123; </span><br><span class="line">            curRes.add(Integer.valueOf(str));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> curRes;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOperator</span><span class="params">(<span class="keyword">char</span> character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> character == <span class="string">'+'</span> || character == <span class="string">'-'</span> || character == <span class="string">'*'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS Divide-And-Conquer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1216 - Valid Palindrome III</title>
      <link href="/11/08/2019/1216/"/>
      <url>/11/08/2019/1216/</url>
      
        <content type="html"><![CDATA[<p>Find the longest Palindrome Subsequence.(lc 516)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidPalindrome</span><span class="params">(String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span> lps = lps(s);</span><br><span class="line">        <span class="keyword">return</span> (n - lps &lt;= k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    longest palindromic subsequence:(lc 516)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">lps</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = <span class="number">2</span> + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i + <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 354 - Russian Doll Envelopes</title>
      <link href="/11/07/2019/354/"/>
      <url>/11/07/2019/354/</url>
      
        <content type="html"><![CDATA[<p>Use Longest-Increasing-Subsequence to solve this problem.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxEnvelopes</span><span class="params">(<span class="keyword">int</span>[][] envelopes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(envelopes == <span class="keyword">null</span> || envelopes.length == <span class="number">0</span> || envelopes[<span class="number">0</span>] == <span class="keyword">null</span> || envelopes[<span class="number">0</span>].length != <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(envelopes, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] arr1, <span class="keyword">int</span>[] arr2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr1[<span class="number">0</span>] == arr2[<span class="number">0</span>])</span><br><span class="line">                    <span class="keyword">return</span> arr2[<span class="number">1</span>] - arr1[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> arr1[<span class="number">0</span>] - arr2[<span class="number">0</span>];</span><br><span class="line">           &#125; </span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[3, 4] cannot contains [3, 3], so we need to put [3, 4] before [3, 3] </span></span><br><span class="line">        <span class="comment">// when sorting otherwise it will be counted as an increasing number if the order is [3, 3], [3, 4]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> tails[] = <span class="keyword">new</span> <span class="keyword">int</span>[envelopes.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        tails[<span class="number">0</span>] = envelopes[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; envelopes.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &lt; tails[<span class="number">0</span>]) &#123;</span><br><span class="line">                tails[<span class="number">0</span>] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (envelopes[i][<span class="number">1</span>] &gt; tails[len]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                tails[len] = envelopes[i][<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tails[binarySearch(tails, <span class="number">0</span>, len, envelopes[i][<span class="number">1</span>])] = envelopes[i][<span class="number">1</span>]; <span class="comment">// 1 2 4 6 -&gt; search 3, return idx 2 --update 1 2 3 6</span></span><br><span class="line">                <span class="comment">//[10,9,2,5,3,4] if no binarySearch, res will be 2, but it's 3, BS will 2,5 -&gt; 2,3, update the last element</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] tails, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tails[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP binary-search Longest-Increasing-Subsequence </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 300 - Longest Increasing Subsequence</title>
      <link href="/11/07/2019/300/"/>
      <url>/11/07/2019/300/</url>
      
        <content type="html"><![CDATA[<p>If you can’t understand the code, check this post <a href="https://segmentfault.com/a/1190000003819886" target="_blank" rel="noopener">link</a></p><p>similar question :lc 354</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//n squared time</span></span><br><span class="line"><span class="comment">//         if (nums.length == 0) &#123;</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         int[] dp = new int[nums.length];</span></span><br><span class="line"><span class="comment">//         dp[0] = 1;</span></span><br><span class="line"><span class="comment">//         int ans = 1;</span></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; dp.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//             int maxval = 0;</span></span><br><span class="line"><span class="comment">//             for (int j = 0; j &lt; i; j++) &#123;</span></span><br><span class="line"><span class="comment">//                 if(nums[i] &gt; nums[j]) &#123;</span></span><br><span class="line"><span class="comment">//                     maxval = Math.max(maxval, dp[j]);</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             dp[i] = maxval + 1;</span></span><br><span class="line"><span class="comment">//             ans = Math.max(ans, dp[i]);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         return ans;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// nlogn time</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] tails = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];<span class="comment">//increasing arr, so we can do binarySearch on it</span></span><br><span class="line">        tails[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; tails[<span class="number">0</span>]) &#123;</span><br><span class="line">                tails[<span class="number">0</span>] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; tails[len]) &#123;</span><br><span class="line">                len++;</span><br><span class="line">                tails[len] = nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tails[binarySearch(tails, <span class="number">0</span>, len, nums[i])] = nums[i]; <span class="comment">// 1 2 4 6 -&gt; search 3, return idx 2 --update 1 2 3 6</span></span><br><span class="line">                <span class="comment">//[10,9,2,5,3,4] if no binarySearch, res will be 2, but it's 3, BS will 2,5 -&gt; 2,3, update the last element</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] tails, <span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (s &lt;= e) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = s + (e - s) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (tails[mid] &gt; target) &#123;</span><br><span class="line">                e = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tails[mid] &lt; target) &#123;</span><br><span class="line">                s = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DP binary-search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1143 - Longest Common Subsequence</title>
      <link href="/11/07/2019/1143/"/>
      <url>/11/07/2019/1143/</url>
      
        <content type="html"><![CDATA[<p>//516 1216 1143 5 those questions are also pretty alike this one.</p><p>In this quetion, i means for s1, range[0, i - 1] and j means for s2, range[0, j - 1]<br>what the Longest Common Subsequence?<br><code>So dp[i][j] means for first i elements in s1 and for first j elements in s2, what the LCS?</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(mn) space O(mn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s1.length() + <span class="number">1</span>][s2.length() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//dp[0][0], dp[0][j], dp[i][0] all = zero</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s1.length(); ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= s2.length(); ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(i - <span class="number">1</span>) == s2.charAt(j - <span class="number">1</span>)) dp[i][j] = <span class="number">1</span> + dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] =  Math.max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> dp[s1.length()][s2.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP Dynamic Programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 516 - Longest Palindromic Subsequence</title>
      <link href="/11/07/2019/516/"/>
      <url>/11/07/2019/516/</url>
      
        <content type="html"><![CDATA[<p>check 680. Valid Palindrome II, lc5, lc1143 for better understanding of this problem.<br>And solution of this question can also been applied to 1216. Valid Palindrome III.</p><p>//516 1216 1143 5 those questions are also pretty alike this one.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()][s.length()];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = s.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;<span class="comment">//single char itself is a valid palindrome.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j == i + <span class="number">1</span>) dp[i][j] = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">else</span> dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//dp[i][j] = dp[i+1][j-1] + 2;// if j-i == 1, [i+1][j-1] will = 0</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);<span class="comment">//same as 680. Valid Palindrome II, you can think of you delete letf or right one, and rest have to be a palindrome.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s.length()-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DP Dynamic Programing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 621 - Task Scheduler</title>
      <link href="/11/06/2019/621/"/>
      <url>/11/06/2019/621/</url>
      
        <content type="html"><![CDATA[<p>The best strategy solving this problem: get max and maxCount, then insert the rest of chars in between.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//The problem actually requires us to make the "distance" between two same tasks up to at least n. </span></span><br><span class="line"><span class="comment">//Thus,if emptySlots is negative, it means that we even have remaining </span></span><br><span class="line"><span class="comment">//tasks to make the "distance" between same tasks longer than n. That is, no idle is needed. Thus,</span></span><br><span class="line"><span class="comment">//idles = Math.max(0, emptySlots - availableTasks); is for covering this case.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//O(n) time O(1) space</span></span><br><span class="line">    <span class="comment">//need to clearify: is n always valid?</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastInterval</span><span class="params">(<span class="keyword">char</span>[] tasks, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] counter = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> task : tasks) &#123;</span><br><span class="line">            counter[task - <span class="string">'A'</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(max == counter[task - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                maxCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(max &lt; counter[task - <span class="string">'A'</span>]) &#123;</span><br><span class="line">                max = counter[task - <span class="string">'A'</span>];<span class="comment">//出现最多的task的出现次数是多少(比如A和B都出现3次，max=3）if both A and B show 3 times, max=3</span></span><br><span class="line">                maxCount = <span class="number">1</span>;<span class="comment">//几个出现最多次数的task（比如A和B都出现3次，maxCount=2） if A and B with max 3, maxCount =2</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> partCount = max - <span class="number">1</span>;<span class="comment">//A (? ?) A (? ?) A   emptyslots = 3 - 1 = 2, 2 intervals</span></span><br><span class="line">        <span class="keyword">int</span> partLength = n - (maxCount - <span class="number">1</span>);<span class="comment">//A (B ? ?) A (B ? ?) ...,</span></span><br><span class="line">        <span class="comment">//3-(2-1)=2, so there are 2 dile slots per interval</span></span><br><span class="line">        <span class="keyword">int</span> emptySlots = partCount * partLength;<span class="comment">//at least there are these emptySlots</span></span><br><span class="line">        <span class="keyword">int</span> availableTasks = tasks.length - max * maxCount;</span><br><span class="line">        <span class="keyword">int</span> idles = Math.max(<span class="number">0</span>, emptySlots - availableTasks);<span class="comment">//if idels = 0, means no idles needed</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tasks.length + idles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode array math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 51 - N-Queens</title>
      <link href="/11/06/2019/51/"/>
      <url>/11/06/2019/51/</url>
      
        <content type="html"><![CDATA[<p>The original solution using a 2 dimensional arr as temp for backtracking. So the space will be <code>O(n^2)</code><br>I improve the space to <code>O(n)</code> using a single arr. chess[i] = j means at ith row, the chess is on jth col.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">//O(n) space(best)     time is factorial, O(N!) time</span></span><br><span class="line"><span class="comment">//backtracking</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//backtracking  n*n space if you use this solution:</span></span><br><span class="line">    <span class="comment">//https://leetcode.com/problems/n-queens/discuss/19808/Accepted-4ms-c%2B%2B-solution-use-backtracking-and-bitmask-easy-understand.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//I change to O(n) space myself</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] chess = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(chess, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">        solve(res, chess, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">solve</span><span class="params">(List&lt;List&lt;String&gt;&gt; res, <span class="keyword">int</span>[] chess, <span class="keyword">int</span> row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row == chess.length) &#123;</span><br><span class="line">            res.add(construct(chess));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> col = <span class="number">0</span>; col &lt; chess.length; col++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid(chess, row, col)) &#123;</span><br><span class="line">                chess[row] = col;</span><br><span class="line">                solve(res, chess, row + <span class="number">1</span>);</span><br><span class="line">                chess[row] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(<span class="keyword">int</span>[] chess, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">          <span class="keyword">if</span> (chess[i] == col) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">// check all cols</span></span><br><span class="line">          <span class="keyword">if</span> (chess[i] + i == col + row) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 45 degree</span></span><br><span class="line">          <span class="keyword">if</span> (chess[i] - i == col - row) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">//check 135</span></span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">construct</span><span class="params">(<span class="keyword">int</span>[] chess)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chess.length; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] temp = <span class="keyword">new</span> <span class="keyword">char</span>[chess.length];</span><br><span class="line">            Arrays.fill(temp, <span class="string">'.'</span>);</span><br><span class="line">            temp[chess[i]] = <span class="string">'Q'</span>;</span><br><span class="line">            path.add(<span class="keyword">new</span> String(temp));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 689 - Maximum Sum of 3 Non-Overlapping Subarrays</title>
      <link href="/11/06/2019/689/"/>
      <url>/11/06/2019/689/</url>
      
        <content type="html"><![CDATA[<p>Facebook follow up question.</p><p>preprocessed sum is for gettting sub-arr sum in O(1) time.</p><p><code>posLeft</code>is used to store left window max’s start index(as we have to return it as res)<br><code>posRight</code>is is used to store right window max’s start index</p><p>At the last iteration, exhaust all the possible middle start point (range from k to n-2*k) and get the res using pre-stored start index.<br>There are many similar questions in leetcode such as <code>max area histogram</code>…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length, maxsum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>], posLeft = <span class="keyword">new</span> <span class="keyword">int</span>[n], posRight = <span class="keyword">new</span> <span class="keyword">int</span>[n], ans = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) sum[i+<span class="number">1</span>] = sum[i]+nums[i];</span><br><span class="line">        <span class="comment">// DP for starting index of the left max sum interval</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k, tot = sum[k]-sum[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i+<span class="number">1</span>]-sum[i+<span class="number">1</span>-k] &gt; tot) &#123;</span><br><span class="line">                posLeft[i] = i+<span class="number">1</span>-k;</span><br><span class="line">                tot = sum[i+<span class="number">1</span>]-sum[i+<span class="number">1</span>-k];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                posLeft[i] = posLeft[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// DP for starting index of the right max sum interval</span></span><br><span class="line">       <span class="comment">// caution: the condition is "&gt;= tot" for right interval, and "&gt; tot" for left interval</span></span><br><span class="line">       <span class="comment">// This is to make sure that we always choose leftmost start idx</span></span><br><span class="line">        posRight[n-k] = n-k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n-k-<span class="number">1</span>, tot = sum[n]-sum[n-k]; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum[i+k]-sum[i] &gt;= tot) &#123;</span><br><span class="line">                posRight[i] = i;</span><br><span class="line">                tot = sum[i+k]-sum[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                posRight[i] = posRight[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// test all possible middle interval</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt;= n-<span class="number">2</span>*k; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> l = posLeft[i-<span class="number">1</span>], r = posRight[i+k];</span><br><span class="line">            <span class="keyword">int</span> tot = (sum[i+k]-sum[i]) + (sum[l+k]-sum[l]) + (sum[r+k]-sum[r]);</span><br><span class="line">            <span class="keyword">if</span> (tot &gt; maxsum) &#123;</span><br><span class="line">                maxsum = tot;</span><br><span class="line">                ans[<span class="number">0</span>] = l; ans[<span class="number">1</span>] = i; ans[<span class="number">2</span>] = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 416 - Partition Equal Subset Sum</title>
      <link href="/11/05/2019/416/"/>
      <url>/11/05/2019/416/</url>
      
        <content type="html"><![CDATA[<p>This problem is pretty much alike the 518. Coin Change 2.<br>Difference are:</p><ul><li>We CANNOT reuse an element while it can be reused in LT518. </li><li>We have to preprocess the input. Then this question convert to:<br><code>Can we make a sum/2 using the element in arr or not?</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//I just figured out the differences between this problem and </span></span><br><span class="line">    <span class="comment">//518. Coin Change 2. In this problem, we CANNOT reuse an element while it can be reused in LT518. </span></span><br><span class="line">    <span class="comment">//That is why we have dp[i-1][j-nums[i-1]] in this problem and dp[i][j-coins[i-1]] in LT518</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPartition</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sum /= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"><span class="comment">//         boolean[][] dp = new boolean[n+1][sum+1];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         dp[0][0] = true;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt; n+1; i++) &#123;</span></span><br><span class="line"><span class="comment">//             dp[i][0] = true;//不用任何数字，可以凑成0sum</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         for (int j = 1; j &lt; sum+1; j++) &#123;</span></span><br><span class="line"><span class="comment">//             dp[0][j] = false;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         for (int i = 1; i &lt;= n; i++) &#123;</span></span><br><span class="line"><span class="comment">//             for (int j = 1; j &lt;= sum; j++) &#123;</span></span><br><span class="line"><span class="comment">//                 if (j &gt;= nums[i-1]) &#123;</span></span><br><span class="line">                       <span class="comment">//both i-1 so cur only depend on prev row</span></span><br><span class="line"><span class="comment">//                     dp[i][j] = (dp[i - 1][j] || dp[i - 1][j - nums[i-1]]);// dp[i - 1] because each ele can only be used once</span></span><br><span class="line"><span class="comment">//                 &#125;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return dp[n][sum];</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment">//Every loop of nums refreshes dp array. We might get dp[i] from dp[i-num] whose index is smaller than i. If we increase the index of sum from 0 to sum, we will get dp[i] from dp[i-num] , while dp[i-num] has been updated in this loop. This dp[i-num] is not the number we got from the previous loop.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// So why would we do this? This is because the numbers in nums can only be used once. If we can choose each number several times, we have to increase i from 0 to sum. Which means, if we are going to choose dp[i], we have to consider the situation where dp[i] has been chosen before. In this case, dp[i] is updated from dp[i-num] which is in the same loop with dp[i]. This dp[i-num] we use is a kind of result where dp[i] has been chosen.</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[sum+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//Arrays.fill(dp, false);</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sum; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= num) &#123;</span><br><span class="line">                    dp[i] = dp[i] || dp[i - num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[sum];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 173 - Binary Search Tree Iterator</title>
      <link href="/11/05/2019/173/"/>
      <url>/11/05/2019/173/</url>
      
        <content type="html"><![CDATA[<p>This is just a iterative BST in-order traversal. Check LC94 out. You can search in my blog.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BSTIterator</span> </span>&#123;</span><br><span class="line">    <span class="comment">//or O(n) time O(n) space preprocess</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// O(h) space</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    TreeNode cur;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BSTIterator</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        cur = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//same as inorder traversal, amortized O(1) time, worst O(N) time</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur =  stack.pop();</span><br><span class="line">        <span class="keyword">int</span> val = cur.val;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** <span class="doctag">@return</span> whether we have a next smallest number */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> !stack.isEmpty() || cur != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your BSTIterator object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * BSTIterator obj = new BSTIterator(root);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.next();</span></span><br><span class="line"><span class="comment"> * boolean param_2 = obj.hasNext();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BST Iterator amortized in-order </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 94 - Binary Tree Inorder Traversal</title>
      <link href="/11/05/2019/94/"/>
      <url>/11/05/2019/94/</url>
      
        <content type="html"><![CDATA[<h2 id="Res-of-inorder-traversal-would-be-an-increasing-arr"><a href="#Res-of-inorder-traversal-would-be-an-increasing-arr" class="headerlink" title="Res of inorder traversal would be an increasing arr."></a>Res of inorder traversal would be an increasing arr.</h2><p>The iterative way of in-order traversal is different from that of pre and post order traversal.<br><code>So you have to remember the code</code> as it is very important and can be applied to multiple questions.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">//     public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         helper(res, root);</span></span><br><span class="line"><span class="comment">//         return res;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void helper(List&lt;Integer&gt; res, TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">//         if (root == null) return;</span></span><br><span class="line"><span class="comment">//         helper(res, root.left);</span></span><br><span class="line"><span class="comment">//         res.add(root.val);</span></span><br><span class="line"><span class="comment">//         helper(res, root.right);</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        TreeNode cur = root;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> || !s.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">                s.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = s.pop();</span><br><span class="line">            res.add(cur.val);</span><br><span class="line">            cur = cur.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Morris inorder tree traversal   time O(n) space O(1)</span></span><br><span class="line">        <span class="comment">// List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span></span><br><span class="line">        <span class="comment">// TreeNode predecessor = null;</span></span><br><span class="line">        <span class="comment">// TreeNode cur = root;</span></span><br><span class="line">        <span class="comment">// while (cur != null)&#123;</span></span><br><span class="line">        <span class="comment">//     if (cur.left != null)&#123; //root.left exist</span></span><br><span class="line">        <span class="comment">//         //find predecessor(right most node in first left node)</span></span><br><span class="line">        <span class="comment">//         predecessor = cur.left;</span></span><br><span class="line">        <span class="comment">//         while (predecessor.right != null &amp;&amp; predecessor.right != cur) &#123;</span></span><br><span class="line">        <span class="comment">//             predecessor = predecessor.right;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//         //predecessor.right exists(we wire it for tracking back purpose before)</span></span><br><span class="line">        <span class="comment">//         if (predecessor.right != null)&#123;</span></span><br><span class="line">        <span class="comment">//             predecessor.right = null;</span></span><br><span class="line">        <span class="comment">//             res.add(cur.val);</span></span><br><span class="line">        <span class="comment">//             cur = cur.right;</span></span><br><span class="line">        <span class="comment">//         &#125; else &#123;//predecessor.right not exists</span></span><br><span class="line">        <span class="comment">//             predecessor.right = cur;//(wire it for tracking back)</span></span><br><span class="line">        <span class="comment">//             cur = cur.left;</span></span><br><span class="line">        <span class="comment">//         &#125;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;//root.left not exist</span></span><br><span class="line">        <span class="comment">//         res.add(cur.val);</span></span><br><span class="line">        <span class="comment">//         cur = cur.right;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode in-order recursive iterative morris-traversal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 75 - Sort Colors</title>
      <link href="/11/05/2019/75/"/>
      <url>/11/05/2019/75/</url>
      
        <content type="html"><![CDATA[<p>Similar question: 283 - Move Zeroes</p><p>notice here we have to maintain the relative order of the non-zero elements.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2 different one pass constant space solution</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//swap O(1) space</span></span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> b = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, i, r);</span><br><span class="line">                r++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                swap(nums, i, b);</span><br><span class="line">                i--;<span class="comment">//because this might be 0, so we have to check again</span></span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//non-swap O(1) space</span></span><br><span class="line">        <span class="comment">// int n0 = -1, n1 = -1, n2 = -1;</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     if (nums[i] == 0) &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//         nums[++n1] = 1;</span></span><br><span class="line">        <span class="comment">//         nums[++n0] = 0;</span></span><br><span class="line">        <span class="comment">//     &#125; else if (nums[i] == 1) &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//         nums[++n1] = 1;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         nums[++n2] = 2;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 283 - Move Zeroes</title>
      <link href="/11/05/2019/283/"/>
      <url>/11/05/2019/283/</url>
      
        <content type="html"><![CDATA[<p>Similar question: 75. Sort Colors</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//if(i != start)&#123;</span></span><br><span class="line">                    exchange(nums, i, start);</span><br><span class="line">                <span class="comment">//&#125;</span></span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Swap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 93 - Restore IP Addresses</title>
      <link href="/11/05/2019/93/"/>
      <url>/11/05/2019/93/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dfs  3*3*3 = 27 time complexity?</span></span><br><span class="line">    <span class="comment">//If one already put a dot that leaves only 3 possibilities for the next dot to be placed : after one digit, after two digits, or after three digits. The first dot has only 3 available slots as well.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        doRestore(result, <span class="string">""</span>, s, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRestore</span><span class="params">(List&lt;String&gt; result, String path, String s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() &amp;&amp; k == <span class="number">4</span>) &#123;</span><br><span class="line">            result.add(path.substring(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span> (s.isEmpty() || k == <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (s.charAt(<span class="number">0</span>) == <span class="string">'0'</span> ? <span class="number">1</span> : <span class="number">3</span>) &amp;&amp; i &lt;= s.length(); i++) &#123; <span class="comment">// Avoid leading 0</span></span><br><span class="line">            String part = s.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (Integer.valueOf(part) &lt;= <span class="number">255</span>)</span><br><span class="line">                doRestore(result, path + <span class="string">"."</span> + part, s.substring(i), k + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 287 - Find the Duplicate Number</title>
      <link href="/11/05/2019/287/"/>
      <url>/11/05/2019/287/</url>
      
        <content type="html"><![CDATA[<p>Similar question: Linked List Cycle II<br><img src="https://leetcode.com/problems/linked-list-cycle-ii/Figures/142/diagram.png" alt="287"><br>Basically, you will have to have 2 pointers, fast and slow, and fast run 2 step each time, slow run 1 step each time, 2 pointers stop at the first intersection. Keep moving the slow form this intersection and have a new pointer start form the start point also with 1 step, the second interscetion will be the duplicate one. </p><p>//和442的区别是：1.只能有一个重复的数字。2.不能modify array</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//         Set&lt;Integer&gt; seen = new HashSet&lt;Integer&gt;();</span></span><br><span class="line"><span class="comment">//         for (int num : nums) &#123;</span></span><br><span class="line"><span class="comment">//             if (seen.contains(num)) &#123;</span></span><br><span class="line"><span class="comment">//                 return num;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//             seen.add(num);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//         return -1;</span></span><br><span class="line">        <span class="keyword">int</span> hare = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> tortoise = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        tortoise = nums[tortoise];<span class="comment">//because there is no 0 in nums, so nums[0] can't be a part of the traversal.</span></span><br><span class="line">        hare = nums[nums[hare]];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (hare != tortoise) &#123;</span><br><span class="line">            tortoise = nums[tortoise];</span><br><span class="line">            hare = nums[nums[hare]];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> intersection = tortoise;</span><br><span class="line">        <span class="keyword">int</span> start = nums[<span class="number">0</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (intersection != start) &#123;</span><br><span class="line">            intersection = nums[intersection];</span><br><span class="line">            start = nums[start];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> intersection;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 442 - Find All Duplicates in an Array</title>
      <link href="/11/05/2019/442/"/>
      <url>/11/05/2019/442/</url>
      
        <content type="html"><![CDATA[<p>The key is there always a corresponding index exist in the arr. So we can make use of this attribute to solve this question in O(1) space.</p><p>//和287的区别：多个重复数字，并且可以modify nums来做标记。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">findDuplicates</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n), space O(n), use hashset</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time O(n) space O(1), notice here 1&lt;=a[i]&lt;=n</span></span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = Math.abs(nums[i]) - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[index] &lt; <span class="number">0</span>) &#123;<span class="comment">//negative means we meet this before</span></span><br><span class="line">               res.add(index + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//mark as visited</span></span><br><span class="line">               nums[index] = -nums[index];</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 56 - Merge Intervals</title>
      <link href="/11/04/2019/56/"/>
      <url>/11/04/2019/56/</url>
      
        <content type="html"><![CDATA[<p>Sort the intervals according to the start time of each interval.<br>Keep a list to track the res.<br><code>if (list.isEmpty() || list.peekLast()[1] &lt; interval[0])</code> there is no interval.<br>if there is a overlap, change the end time of the last element in the list.<br><code>list.getLast()[1] = Math.max(list.peekLast()[1], interval[1]);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//class Solution &#123;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for an interval.</span></span><br><span class="line"><span class="comment"> * public class Interval &#123;</span></span><br><span class="line"><span class="comment"> *     int start;</span></span><br><span class="line"><span class="comment"> *     int end;</span></span><br><span class="line"><span class="comment"> *     Interval() &#123; start = 0; end = 0; &#125;</span></span><br><span class="line"><span class="comment"> *     Interval(int s, int e) &#123; start = s; end = e; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Time complexity: O(nlogn)</span></span><br><span class="line">    <span class="comment">//Space complexity: O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span>(intervals == <span class="keyword">null</span> || intervals.length &lt; <span class="number">2</span>) <span class="keyword">return</span> intervals;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> a[<span class="number">0</span>] - b[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// Arrays.sort(intervals, (a, b) -&gt; a[0] - b[0]);</span></span><br><span class="line"></span><br><span class="line">        LinkedList&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//Deque&lt;int[]&gt; list = new ArrayDeque&lt;&gt;();</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.isEmpty() || list.peekLast()[<span class="number">1</span>] &lt; interval[<span class="number">0</span>]) &#123;</span><br><span class="line">                list.add(interval);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//overlap</span></span><br><span class="line">                list.getLast()[<span class="number">1</span>] = Math.max(list.peekLast()[<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// int[][] res = new int[list.size()][2];</span></span><br><span class="line">        <span class="comment">// int index = 0;</span></span><br><span class="line">        <span class="comment">// for(int[] interval: list) &#123;</span></span><br><span class="line">        <span class="comment">//     res[index++] = interval;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Array Interval List </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 1055 - Shortest Way to Form String</title>
      <link href="/11/04/2019/1055/"/>
      <url>/11/04/2019/1055/</url>
      
        <content type="html"><![CDATA[<p>Whether target can be formed by source’s subsequence.<br>t: “xzyxz”<br>s: “xyz”<br>return 3 because <code>t = &quot;xz&quot; + &quot;y&quot; + &quot;xz&quot;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先问能不能，简化成一个判断t里面的char是否都在s中，用一个hashset把s中的字母存一下，iterate 一下t就好</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(M * N)  space O(1) (brute force)</span></span><br><span class="line">        <span class="comment">// char[] sArr = source.toCharArray(), tArr = target.toCharArray();</span></span><br><span class="line">        <span class="comment">// int res = 0;</span></span><br><span class="line">        <span class="comment">// int i = 0;</span></span><br><span class="line">        <span class="comment">// while (i &lt; tArr.length) &#123;</span></span><br><span class="line">        <span class="comment">//     int temp = i;</span></span><br><span class="line">        <span class="comment">//     for (int j = 0; j &lt; sArr.length; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         if (i &lt; tArr.length &amp;&amp; sArr[j] == tArr[i])</span></span><br><span class="line">        <span class="comment">//             i++;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     if (i == temp) return -1;</span></span><br><span class="line">        <span class="comment">//     res++;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return res;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//O(NlogM)</span></span><br><span class="line">        <span class="keyword">char</span>[] sArr = source.toCharArray(), tArr = target.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        List&lt;Integer&gt;[] idx = <span class="keyword">new</span> List[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) idx[i] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sArr.length; i++) idx[sArr[i] - <span class="string">'a'</span>].add(i);</span><br><span class="line">        <span class="keyword">int</span> jj = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ii = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ii &lt; tArr.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; curList = idx[tArr[ii] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span> (curList.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = binarySearch(curList,jj); <span class="comment">//get insert position</span></span><br><span class="line">            <span class="keyword">if</span> (k == curList.size()) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                jj = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jj = curList.get(k) + <span class="number">1</span>;</span><br><span class="line">                ii++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;Integer&gt; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = arr.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + ((r - l) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (arr.get(mid) == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr.get(mid) &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//time O(N) , and build the map cost 26 * M</span></span><br><span class="line">    <span class="comment">//     char[] cs = source.toCharArray(), ts = target.toCharArray();</span></span><br><span class="line">    <span class="comment">//     int[][] idx = new int[26][cs.length];</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; cs.length; i++) idx[cs[i] - 'a'][i] = i + 1;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; 26; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         for (int j = cs.length - 1, pre = 0; j &gt;= 0; j--) &#123;</span></span><br><span class="line">    <span class="comment">//             if (idx[i][j] == 0) idx[i][j] = pre;</span></span><br><span class="line">    <span class="comment">//             else pre = idx[i][j];</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     int res = 1, j = 0;</span></span><br><span class="line">    <span class="comment">//     for (int i = 0; i &lt; ts.length; i++) &#123;</span></span><br><span class="line">    <span class="comment">//         if (j == cs.length) &#123;</span></span><br><span class="line">    <span class="comment">//             j = 0;</span></span><br><span class="line">    <span class="comment">//             res++;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//         if (idx[ts[i] - 'a'][0] == 0) return -1;</span></span><br><span class="line">    <span class="comment">//         j = idx[ts[i] - 'a'][j];</span></span><br><span class="line">    <span class="comment">//         if (j == 0 ) &#123;</span></span><br><span class="line">    <span class="comment">//             res++;</span></span><br><span class="line">    <span class="comment">//             i--;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     return res;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode binarySearch DP Greedy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 986 - Interval List Intersections</title>
      <link href="/11/04/2019/986/"/>
      <url>/11/04/2019/986/</url>
      
        <content type="html"><![CDATA[<p>After getting lo and hi, you need to advance the pointer.<br>Compare the end, and the one with smaller end with be discarded because it can’t contribute to the next intersection anymore.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] intervalIntersection(<span class="keyword">int</span>[][] A, <span class="keyword">int</span>[][] B) &#123;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; A.length &amp;&amp; j &lt; B.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> lo = Math.max(A[i][<span class="number">0</span>], B[j][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">int</span> hi = Math.min(A[i][<span class="number">1</span>], B[j][<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (lo &lt;= hi) &#123;</span><br><span class="line">                res.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;lo, hi&#125;);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            <span class="keyword">if</span> (A[i][<span class="number">1</span>] &lt; B[j][<span class="number">1</span>]) &#123;<span class="comment">//the one with smaller end should be discarded</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[res.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode 2-pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 5 - Longest Palindromic Substring</title>
      <link href="/11/03/2019/5/"/>
      <url>/11/03/2019/5/</url>
      
        <content type="html"><![CDATA[<p>For better understanding of this problem, I strongly recommend <code>using both the DP and 2-pointer</code> solution.<br>And once you can solve this problem using DP, you can also solve <code>lc516</code> and <code>lc1143</code> which are all very similar questions.(<code>search in my blog</code>)<br>And I strongly recommend take a look at those 2 questions for better understanding of this kind of “longest XXX Substring/Subsequence” problem.</p><p>//516 1216 1143 those questions are also pretty alike this one.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> lo, maxLen;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time n^2 space n^2</span></span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n - <span class="number">1</span>; j++) &#123; <span class="comment">//expand, not contract</span></span><br><span class="line">                dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt;= <span class="number">2</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; (j - i + <span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    lo = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> s.substring(lo, lo + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time n^2 space O(1)</span></span><br><span class="line"><span class="comment">//         int len = s.length();</span></span><br><span class="line"><span class="comment">//     if (len &lt; 2)</span></span><br><span class="line"><span class="comment">// return s;</span></span><br><span class="line"><span class="comment">//         for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//             extend(s, i, i + 1);//even</span></span><br><span class="line"><span class="comment">//             extend(s, i, i);//odd</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return s.substring(lo, lo + maxLen);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     public void extend (String s, int j, int k) &#123;</span></span><br><span class="line"><span class="comment">//         while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span></span><br><span class="line"><span class="comment">//             j--;</span></span><br><span class="line"><span class="comment">//             k++;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         //after valid one, the j and k will be one more than it should be, so we use k-j-1 rather than k-j+1</span></span><br><span class="line"><span class="comment">//         if (maxLen &lt; k - j - 1) &#123;</span></span><br><span class="line"><span class="comment">//             lo = j + 1;</span></span><br><span class="line"><span class="comment">//        maxLen = k - j - 1;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode dp Dynamic Programing 2-pointer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 518 - Coin Change 2</title>
      <link href="/11/02/2019/518/"/>
      <url>/11/02/2019/518/</url>
      
        <content type="html"><![CDATA[<p>Use DP to solve this problem and use rolling arr to optimize the space in to O(amount).<br>Similar question: LC416.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> amount, <span class="keyword">int</span>[] coins)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time amount * n, space amount * n</span></span><br><span class="line">        <span class="comment">// int[][] dp = new int[coins.length+1][amount+1];</span></span><br><span class="line">        <span class="comment">//这里是指amount是0的话总至少有一种方法就是不用任何硬币？</span></span><br><span class="line">        <span class="comment">// dp[0][0] = 1;</span></span><br><span class="line">        <span class="comment">// //i means how many coins </span></span><br><span class="line">        <span class="comment">// dp[0][j] = 0, so don't have to initialize</span></span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= coins.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp[i][0] = 1;</span></span><br><span class="line">        <span class="comment">//     for (int j = 1; j &lt;= amount; j++) &#123;</span></span><br><span class="line">        <span class="comment">//         dp[i - 1][j]不用这个硬币，到这个amount dp[i][j - coins[i - 1]]用这个硬币，到这个amount</span></span><br><span class="line">        <span class="comment">//         dp[i][j] = dp[i - 1][j] + (j &gt;= coins[i - 1] ? dp[i][j - coins[i - 1]]: 0); //i-1 prev row, i cur row</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// return dp[coins.length][amount];</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//time amount * n, space amount</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= amount; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= coins[i]) &#123;</span><br><span class="line">                    dp[j] = dp[j] + dp[j - coins[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 322 - Coin Change</title>
      <link href="/11/02/2019/322/"/>
      <url>/11/02/2019/322/</url>
      
        <content type="html"><![CDATA[<p>The difference between this question and the one can be solved with greedy is that this in this question, the denominations of the coins are decided by the input arr.<br>If you are given an arr of denomination with <code>1</code> in it,<br>you can just use greedy to solve the problem in <code>linear time</code>.</p><p>ex: coins = [1,2,5] amount = 11<br> 5 + 5 + 1</p><p>but if the input has no 1 in it, you will have to use DP<br>and the time complexity will be <code>O(n * amount)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time O(n * amount) space O(amount)</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, amount + <span class="number">1</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//no way to make 0 amount</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; j++) &#123;</span><br><span class="line">                <span class="comment">//don't use cur or use cur</span></span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[amount] == amount + <span class="number">1</span> ?  -<span class="number">1</span> : dp[amount];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里之所以使用dp是因为面额是自定义的。如果使用贪心算法，有可能出现硬币凑不整的情况。比如 5，6 凑10， 贪心算法会凑不整。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dynamic Programing DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 449 - Serialize and Deserialize BST</title>
      <link href="/11/02/2019/449/"/>
      <url>/11/02/2019/449/</url>
      
        <content type="html"><![CDATA[<p>use max-min boundary to deserialize<br>2 ways to deserialize:</p><ul><li>use queue</li><li>use reference type (such as array) as idx and pass it to parameter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Codec</span> </span>&#123;</span><br><span class="line">    <span class="comment">//normal way</span></span><br><span class="line">    <span class="comment">// private static final String SPLITER = ",";</span></span><br><span class="line">    <span class="comment">// private static final String NULL = "N";</span></span><br><span class="line">    <span class="comment">// // Encodes a tree to a single string.</span></span><br><span class="line">    <span class="comment">// public String serialize(TreeNode root) &#123;</span></span><br><span class="line">    <span class="comment">//     StringBuilder st = new StringBuilder();</span></span><br><span class="line">    <span class="comment">//     serialize(root, st);</span></span><br><span class="line">    <span class="comment">//     return st.toString();</span></span><br><span class="line">    <span class="comment">// &#125;  </span></span><br><span class="line">    <span class="comment">// public void serialize(TreeNode root, StringBuilder st) &#123;</span></span><br><span class="line">    <span class="comment">//     if (root == null) st.append(NULL + SPLITER);</span></span><br><span class="line">    <span class="comment">//     else &#123;</span></span><br><span class="line">    <span class="comment">//         st.append(root.val + SPLITER);</span></span><br><span class="line">    <span class="comment">//         serialize(root.left, st);</span></span><br><span class="line">    <span class="comment">//         serialize(root.right, st);</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// // Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="comment">// public TreeNode deserialize(String data) &#123;</span></span><br><span class="line">    <span class="comment">//     Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">    <span class="comment">//     queue.addAll(Arrays.asList(data.split(SPLITER)));</span></span><br><span class="line">    <span class="comment">//     return deseralize(queue);</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// public TreeNode deseralize(Queue&lt;String&gt; queue) &#123;</span></span><br><span class="line">    <span class="comment">//     String cur = queue.poll();</span></span><br><span class="line">    <span class="comment">//     if (cur.equals(NULL)) return null;</span></span><br><span class="line">    <span class="comment">//     TreeNode root = new TreeNode(Integer.parseInt(cur));</span></span><br><span class="line">    <span class="comment">//     root.left = deseralize(queue);</span></span><br><span class="line">    <span class="comment">//     root.right = deseralize(queue);</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">     <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        preorder(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">preorder</span><span class="params">(TreeNode root, StringBuilder sb)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        sb.append((<span class="keyword">char</span>)root.val);</span><br><span class="line">        preorder(root.left, sb);</span><br><span class="line">        preorder(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(data==<span class="keyword">null</span> || data.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chs = data.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> constructTree(chs, <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>&#125;, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//idx 是引用类型？ 用单个数字变量替换不可以   (Do not use class member/global/static variables to store states)</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">constructTree</span><span class="params">(<span class="keyword">char</span>[] chs, <span class="keyword">int</span>[] idx, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(idx[<span class="number">0</span>]==chs.length) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> value = (<span class="keyword">int</span>)chs[idx[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">if</span>(value &lt; low || value &gt; high) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(value);</span><br><span class="line">        idx[<span class="number">0</span>]++;</span><br><span class="line">        root.left = constructTree(chs, idx, low, value);</span><br><span class="line">        root.right = constructTree(chs, idx, value, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 297 - Serialize and Deserialize Binary Tree</title>
      <link href="/11/01/2019/297/"/>
      <url>/11/01/2019/297/</url>
      
        <content type="html"><![CDATA[<p>Good question with many variations that each could be ask as a follow up when an interview.</p><h2 id="These-are-the-3-most-frequent-asked-follow-ups"><a href="#These-are-the-3-most-frequent-asked-follow-ups" class="headerlink" title="These are the 3 most frequent asked follow ups."></a>These are the 3 most frequent asked follow ups.</h2><p><code>N-array-tree/BST/encoded string should be as compact as possible</code></p><p>for normal question, you can add null and spliter into the preorder traversal. </p><p>for <code>N-array-tree</code>, you can store the val and it’s children’s size as a pair into the stack. (code implementation down below)</p><p>for <code>BST</code>, you can use the max-min boundary checkout my blog here <a href="https://haichao.us/11/02/2019/449/" target="_blank" rel="noopener">449</a></p><p>for <code>encoded string should be as compact as possible</code> you can think one node as a signle char character, (in java, UTF16 been used), so you can use a char array to store the res, no spliter needed. code implementation here for BST <a href="https://haichao.us/11/02/2019/449/" target="_blank" rel="noopener">449</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SPLITER = <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String NULL = <span class="string">"N"</span>;</span><br><span class="line">    / / Encodes a tree to a single string.</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        StringBuilder st = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        serialize(root, st);</span><br><span class="line">        <span class="keyword">return</span> st.toString();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode root, StringBuilder st)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) st.append(NULL + SPLITER);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            st.append(root.val + SPLITER);</span><br><span class="line">            serialize(root.left, st);</span><br><span class="line">            serialize(root.right, st);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deserialize</span><span class="params">(String data)</span> </span>&#123;</span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                 <span class="comment">// Collection.toArray()</span></span><br><span class="line">        queue.addAll(Arrays.asList(data.split(SPLITER)));</span><br><span class="line">        <span class="keyword">return</span> deseralize(queue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">deseralize</span><span class="params">(Queue&lt;String&gt; queue)</span> </span>&#123;</span><br><span class="line">        String cur = queue.poll();</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(NULL)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(Integer.parseInt(cur));</span><br><span class="line">        root.left = deseralize(queue);</span><br><span class="line">        root.right = deseralize(queue);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 感谢 zz 提供代码. 她非让我把她的linkedin放在这儿。。想看就看一下无所谓了</span></span><br><span class="line"><span class="comment">// https://www.linkedin.com/in/zhao-ma-05b828155/</span></span><br><span class="line"><span class="comment">//     针对N-ary树，要注意的问题有：</span></span><br><span class="line"><span class="comment">// 1.序列化时：放入stack时节点的顺序</span></span><br><span class="line"><span class="comment">// 2.分序列化时：如何确定子节点的数量</span></span><br><span class="line"><span class="comment">// 3.是否需要特殊标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Solution:</span></span><br><span class="line"><span class="comment">// 1.因为stack是FILO，所以先取出children序列，然后逆序加入stack中</span></span><br><span class="line"><span class="comment">// 2.在序列化阶段同时记录子节点数目，跟在root值之后</span></span><br><span class="line"><span class="comment">// 3.不需要。因为size可以控制循环轮数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // Encodes a tree to a single string.</span></span><br><span class="line"><span class="comment">//     public String serialize(Node root) &#123;</span></span><br><span class="line"><span class="comment">//         if(root == null) return "";</span></span><br><span class="line"><span class="comment">//         StringBuilder sb = new StringBuilder();</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Stack&lt;Node&gt; stack = new Stack&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         stack.push(root);</span></span><br><span class="line"><span class="comment">//         while(!stack.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//             Node cur = stack.pop();</span></span><br><span class="line"><span class="comment">//             int size = cur.children.size();</span></span><br><span class="line"><span class="comment">//             sb.append(cur.val).append(",");</span></span><br><span class="line"><span class="comment">//             sb.append(size).append(",");</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//             //FILO</span></span><br><span class="line"><span class="comment">//             List&lt;Node&gt; children = cur.children;</span></span><br><span class="line"><span class="comment">//             for(int i = size - 1; i &gt;= 0; i--) &#123;</span></span><br><span class="line"><span class="comment">//                 stack.push(children.get(i));</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return sb.toString();</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//     // Decodes your encoded data to tree.</span></span><br><span class="line"><span class="comment">//     public Node deserialize(String data) &#123;</span></span><br><span class="line"><span class="comment">//         if(data.length() == 0) return null;</span></span><br><span class="line"><span class="comment">//         String[] arr = data.split(",");</span></span><br><span class="line"><span class="comment">//         Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line"><span class="comment">//         for(String s: arr) &#123;</span></span><br><span class="line"><span class="comment">//             queue.offer(s);</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return helper(queue);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     public Node helper(Queue&lt;String&gt; queue) &#123;</span></span><br><span class="line"><span class="comment">//         if(queue.isEmpty()) return null;</span></span><br><span class="line"><span class="comment">//         int cur = Integer.valueOf(queue.poll());</span></span><br><span class="line"><span class="comment">//         int size = Integer.valueOf(queue.poll());</span></span><br><span class="line">        </span><br><span class="line"><span class="comment">//         Node root = new Node(cur, new ArrayList&lt;&gt;());</span></span><br><span class="line"><span class="comment">//         while(size-- &gt; 0) &#123;</span></span><br><span class="line"><span class="comment">//             root.children.add(helper(queue));</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return root;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 236 - Lowest Common Ancestor of a Binary Tree</title>
      <link href="/11/01/2019/236/"/>
      <url>/11/01/2019/236/</url>
      
        <content type="html"><![CDATA[<p>FB recent interview question.</p><h3 id="2-ways-to-solve-this-problem"><a href="#2-ways-to-solve-this-problem" class="headerlink" title="2 ways to solve this problem."></a>2 ways to solve this problem.</h3><p><code>Iterative and recursive</code>. The recursive one is a little bit hard to understand but easier to modify when change to N-array tree. (<code>code for N-array tree will be append at last</code>)</p><p>Beside normal O(N) implementation, Tarjan and Doubling Algorithm can achieve O(logN) time complexity. But interviewer don’t expect you answer with that within a 45 min interview. So these 2 algorithms are just for displaying purpose. </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//time space for Both solutions are O(n)</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//         Share my understanding of what lowestCommonAncestor() does:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// if both p and q exist in Tree rooted at root, then return their LCA</span></span><br><span class="line">        <span class="comment">// if neither p and q exist in Tree rooted at root, then return null</span></span><br><span class="line">        <span class="comment">// if only one of p or q (NOT both of them), exists in Tree rooted at root, return it</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// if (root == null || p == root || q == root) return root;</span></span><br><span class="line">        <span class="comment">// TreeNode left = lowestCommonAncestor(root.left, p, q);</span></span><br><span class="line">        <span class="comment">// TreeNode right = lowestCommonAncestor(root.right, p, q);</span></span><br><span class="line">        <span class="comment">// if (left == null) &#123;</span></span><br><span class="line">        <span class="comment">//     return right;</span></span><br><span class="line">        <span class="comment">// &#125; else if (right == null) &#123;</span></span><br><span class="line">        <span class="comment">//     return left;</span></span><br><span class="line">        <span class="comment">// &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//     //right != null &amp;&amp; left != null</span></span><br><span class="line">        <span class="comment">//     return root;</span></span><br><span class="line">        <span class="comment">// &#125;  </span></span><br><span class="line">        </span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; parent = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        parent.put(root, <span class="keyword">null</span>);</span><br><span class="line">        stack.push(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!(parent.containsKey(p) &amp;&amp; parent.containsKey(q))) &#123;<span class="comment">//or !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            <span class="comment">// right left or left right really doesn't matter</span></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.right, node);</span><br><span class="line">                stack.push(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                parent.put(node.left, node);</span><br><span class="line">                stack.push(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;TreeNode&gt; ancestors = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ancestors.add(p);</span><br><span class="line">            p = parent.get(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ancestors.contains(q))</span><br><span class="line">            q = parent.get(q);</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Time complexity: O(n)</span></span><br><span class="line"><span class="comment">//Space complexity: O(n)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public static TreeNode helper(TreeNode root, TreeNode p, TreeNode q) &#123;</span></span><br><span class="line">    <span class="comment">//     if(root == null) return null;</span></span><br><span class="line">    <span class="comment">//     if(root.val == p.val || root.val == q.val) return root;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//     int count = 0;</span></span><br><span class="line">    <span class="comment">//     TreeNode last = null;</span></span><br><span class="line">    <span class="comment">//     for(TreeNode child: root.children) &#123;</span></span><br><span class="line">    <span class="comment">//         if(count &gt; 1) break; //root can be determined as LCA</span></span><br><span class="line">    <span class="comment">//         TreeNode ans = helper(child, p, q);</span></span><br><span class="line">    <span class="comment">//         if(ans != null) &#123; //can find p/q from current child</span></span><br><span class="line">    <span class="comment">//             count++;</span></span><br><span class="line">    <span class="comment">//             last = ans;</span></span><br><span class="line">    <span class="comment">//         &#125;</span></span><br><span class="line">    <span class="comment">//     &#125;</span></span><br><span class="line">    <span class="comment">//     //count means the number of child nodes to help find p/q </span></span><br><span class="line">    <span class="comment">//     if(count == 0) return null; //cannot find p/q</span></span><br><span class="line">    <span class="comment">//     if(count == 1) return last; //find p/q only from one child</span></span><br><span class="line">    <span class="comment">//     return root;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 76 - Minimum Window Substring</title>
      <link href="/11/01/2019/76/"/>
      <url>/11/01/2019/76/</url>
      
        <content type="html"><![CDATA[<p>Recent facebook question.<br>classic sliding window problem.<br>first you need a counter to track the match count.<br>Extend the window to a valid answer, then contract the window until it’s not a valid window. Extend again…</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n) space O(n) n= s.len + t.len</span></span><br><span class="line">    <span class="comment">//one little improvement: when length of string TT is way too small </span></span><br><span class="line">    <span class="comment">//than the length of string SS and </span></span><br><span class="line">    <span class="comment">//string SS consists of numerous characters which are not present in TT.</span></span><br><span class="line">    <span class="comment">//S = "ABCDDDDDDEEAFFBC" T = "ABC"</span></span><br><span class="line">  <span class="comment">//filtered_S = [(0, 'A'), (1, 'B'), (2, 'C'), (11, 'A'), (14, 'B'), (15, 'C')]</span></span><br><span class="line">  <span class="comment">//Here (0, 'A') means in string S character A is at index 0.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c: t.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">int</span> dicCount = map.getOrDefault(c, <span class="number">0</span>);</span><br><span class="line">            map.put(c, dicCount + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> matchCount = <span class="number">0</span>, startIndex = <span class="number">0</span>, slow = <span class="number">0</span>, minLen = Integer.MAX_VALUE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; s.length(); fast++) &#123;</span><br><span class="line">            <span class="keyword">char</span> ch = s.charAt(fast);</span><br><span class="line">            Integer count = map.get(ch);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//get a match</span></span><br><span class="line">            map.put(ch, count - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//1 -&gt; 0</span></span><br><span class="line">                matchCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span> (matchCount == map.size()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (fast - slow + <span class="number">1</span> &lt; minLen) &#123;</span><br><span class="line">                    minLen = fast - slow + <span class="number">1</span>;</span><br><span class="line">                    startIndex = slow;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// contract the window until matchCount != map.size()</span></span><br><span class="line">                <span class="keyword">char</span> leftMostChar = s.charAt(slow++);</span><br><span class="line">                Integer leftCount = map.get(leftMostChar);</span><br><span class="line">                <span class="keyword">if</span> (leftCount == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//get a math</span></span><br><span class="line">                map.put(leftMostChar, leftCount + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (leftCount == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//0 -&gt; 1</span></span><br><span class="line">                    matchCount--;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> minLen == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(startIndex, startIndex + minLen);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode sliding window </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 37 - Sudoku Solver</title>
      <link href="/11/01/2019/37/"/>
      <url>/11/01/2019/37/</url>
      
        <content type="html"><![CDATA[<p>This is a pretty classic backtracking problem.<br>Two ponints we need to notice:</p><ul><li><p>validcheck: <code>board[3 * (row / 3) + i / 3][3 * (col / 3) + i % 3]</code> can normalize a node to it’s block’s upleft corner.</p></li><li><p>the solve function return boolean</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//brute force 9^81   backtracking: 9*8*7....*1 for one row, not more than (9!)^9</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">solveSudoku</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="keyword">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        solve(board);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// backtracking</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">solve</span><span class="params">(<span class="keyword">char</span>[][] board)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">'.'</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">char</span> c = <span class="string">'1'</span>; c &lt;= <span class="string">'9'</span>; c++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (isValid(board, i, j, c)) &#123;</span><br><span class="line">                            board[i][j] = c;</span><br><span class="line">                            <span class="keyword">if</span> (solve(board)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                            board[i][j] = <span class="string">'.'</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//no way to fill the blank, dead end </span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// all the blanks are filled </span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[row][i] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col]  == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">3</span> * (row / <span class="number">3</span>) + i / <span class="number">3</span>][<span class="number">3</span> * (col / <span class="number">3</span>) + i % <span class="number">3</span>] == c) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS backtracking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 743 - Pacific Atlantic Water Flow</title>
      <link href="/11/01/2019/417/"/>
      <url>/11/01/2019/417/</url>
      
        <content type="html"><![CDATA[<p>This is a dfs problem.<br>You can construct 2 visited matrix for Pacific and Atlantic.<br>After 2 dfs, you will find the boundary by finding the intersection of these 2 matrix.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="comment">//time O(m*n)</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span>[][] pacific = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">boolean</span>[][] atlantic = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//left</span></span><br><span class="line">            dfs(matrix, pacific, i, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//the old height will be 0 initially</span></span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            dfs(matrix, atlantic, i, n - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//top</span></span><br><span class="line">            dfs(matrix, pacific, <span class="number">0</span>, i, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//bottom</span></span><br><span class="line">            dfs(matrix, atlantic, m - <span class="number">1</span>, i, <span class="number">0</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pacific[i][j] &amp;&amp; atlantic[i][j]) &#123;</span><br><span class="line">                    res.add(<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(i, j)));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span> <span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;= n || visited[i][j] || matrix[i][j] &lt; height) <span class="keyword">return</span>;</span><br><span class="line">        visited[i][j] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(matrix, visited, i + <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i, j + <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i - <span class="number">1</span>, j, matrix[i][j]);</span><br><span class="line">        dfs(matrix, visited, i, j - <span class="number">1</span>, matrix[i][j]);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 863 - All Nodes Distance K in Binary Tree</title>
      <link href="/10/30/2019/863/"/>
      <url>/10/30/2019/863/</url>
      
        <content type="html"><![CDATA[<p>Frequent ask question on Amazon interviews.</p><p>We need to find nodes that k nodes from the target.<br>So we have to do it using BFS.</p><ul><li>First, construct a map to store the parent-child relation. Because we need to go up when BFS.</li><li>Second, we need a visited set because we don’t want to revisit the same node twice.(this will happen when BFS meet the root node) </li></ul><p><img src="https://s3-lc-upload.s3.amazonaws.com/uploads/2018/06/28/sketch0.png" alt="863"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//time O(n) space O(n)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        Map&lt;TreeNode, TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();<span class="comment">//key: node, value: parent</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Set&lt;TreeNode&gt; vis = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">            TreeNode cur = q.poll();</span><br><span class="line">            <span class="keyword">if</span> (cur == target) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(cur.left, cur);</span><br><span class="line">                q.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(cur.right, cur);</span><br><span class="line">                q.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        q.clear();</span><br><span class="line">        q.add(target);</span><br><span class="line">        vis.add(target);<span class="comment">//once we go we can't go back, ex: 5 -&gt; 3(root), 3 -&gt; left, right. </span></span><br><span class="line">        <span class="keyword">while</span>(K-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (q.isEmpty()) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> size = q.size();</span><br><span class="line">            <span class="keyword">while</span> (size-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                TreeNode cur = q.poll();</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="keyword">null</span> &amp;&amp; vis.add(cur.left)) q.add(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="keyword">null</span> &amp;&amp; vis.add(cur.right)) q.add(cur.right);</span><br><span class="line">                <span class="keyword">if</span> (map.get(cur) != <span class="keyword">null</span> &amp;&amp; vis.add(map.get(cur))) q.add(map.get(cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) res.add(q.poll().val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 743 - Network Delay Time</title>
      <link href="/10/30/2019/743/"/>
      <url>/10/30/2019/743/</url>
      
        <content type="html"><![CDATA[<p>This is a pretty hard question, but also a frequent ask question in recent google interviews.<br>The best source on the internet is this one <a href="https://www.youtube.com/watch?v=vwLYDeghs_c" target="_blank" rel="noopener">Huahua</a></p><p>Bellman Ford and Dijkstra’s Algorithm can solve this problem, but the second one has better time complexity.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Bellman Ford     </span></span><br><span class="line">    <span class="comment">//Complexity is O(VE), but the problem said N will be no more than 100, so the complexity should be O(E)</span></span><br><span class="line">    <span class="comment">//E = len(times), V = N in this problem</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Dijkstra's Algorithm  time:ElogE, space:O(N+E), the size of the graph O(E), plus the size of the other objects used O(N).</span></span><br><span class="line">    <span class="comment">//one source, mutilple destinations, shortest pass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(<span class="keyword">int</span>[][] times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;<span class="keyword">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(N + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= N; i++) graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] time : times) graph.get(time[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">        <span class="comment">// PriorityQueue&lt;int[]&gt; pq = new PriorityQueue&lt;&gt;(new Comparator&lt;int[]&gt;()&#123;</span></span><br><span class="line">        <span class="comment">//     public int compare(int[] a, int[] b) &#123;</span></span><br><span class="line">        <span class="comment">//         return a[1] - b[1];</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;);</span></span><br><span class="line">        PriorityQueue&lt;<span class="keyword">int</span>[]&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;K, <span class="number">0</span>&#125;); <span class="comment">//0: dis from source</span></span><br><span class="line">        Set&lt;Integer&gt; visited = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> dist = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] curr = pq.poll();</span><br><span class="line">            <span class="keyword">if</span>(!visited.add(curr[<span class="number">0</span>])) <span class="keyword">continue</span>;</span><br><span class="line">            dist = curr[<span class="number">1</span>];<span class="comment">//the last one is always the biggest one.</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span>[] neighbor : graph.get(curr[<span class="number">0</span>])) &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited.contains(neighbor[<span class="number">0</span>])) pq.offer(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;neighbor[<span class="number">0</span>], neighbor[<span class="number">1</span>] + curr[<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> visited.size() == N ? dist : -<span class="number">1</span>;</span><br><span class="line">    &#125;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode Dijkstra Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog Manual</title>
      <link href="/10/30/2019/hello-world/"/>
      <url>/10/30/2019/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Most of the posts are about leetcode.<br>I’ve done more than 500+ lc question and you can search any question you want.<br>Solutions that I posted are the best I can find online.<br>Feel free to email me if you have any question about my post. Happy coding!</p><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><p>Katherine Ma：</p><blockquote><ul><li>all to reply (multiple times)</li><li>the screen is broken when I moved in</li><li>Used to work on Leetcode when I wrote this solution, before 2019/02.<br><a href="https://leetcode.com/problems/divide-two-integers/discuss/142849/C%2B%2BJavaPython-Should-Not-Use-%22long%22-Int" target="_blank" rel="noopener">ref</a></li><li>I’ve never been a place that I went 3 days ago.</li></ul></blockquote>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
